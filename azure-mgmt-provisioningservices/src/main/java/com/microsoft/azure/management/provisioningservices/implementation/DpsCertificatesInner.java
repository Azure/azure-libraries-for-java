/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.provisioningservices.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.management.provisioningservices.CertificateBodyDescription;
import com.microsoft.azure.management.provisioningservices.CertificatePurpose;
import com.microsoft.azure.management.provisioningservices.ErrorDetailsException;
import com.microsoft.azure.management.provisioningservices.VerificationCodeRequest;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import okhttp3.ResponseBody;
import org.apache.commons.codec.binary.Base64;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in DpsCertificates.
 */
public class DpsCertificatesInner {
    /** The Retrofit service to perform REST calls. */
    private DpsCertificatesService service;
    /** The service client containing this operation class. */
    private IotDpsClientImpl client;

    /**
     * Initializes an instance of DpsCertificatesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public DpsCertificatesInner(Retrofit retrofit, IotDpsClientImpl client) {
        this.service = retrofit.create(DpsCertificatesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for DpsCertificates to be
     * used by Retrofit to perform actually REST calls.
     */
    interface DpsCertificatesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates get" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates/{certificateName}")
        Observable<Response<ResponseBody>> get(@Path("certificateName") String certificateName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates/{certificateName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Path("certificateName") String certificateName, @Query("api-version") String apiVersion, @Header("If-Match") String ifMatch, @Header("accept-language") String acceptLanguage, @Body CertificateBodyDescription certificateDescription, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates/{certificateName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Path("certificateName") String certificateName, @Header("If-Match") String ifMatch, @Query("certificate.name") String certificatename, @Query("certificate.rawBytes") String certificaterawBytes, @Query("certificate.isVerified") Boolean certificateisVerified, @Query("certificate.purpose") CertificatePurpose certificatepurpose, @Query("certificate.created") DateTime certificatecreated, @Query("certificate.lastUpdated") DateTime certificatelastUpdated, @Query("certificate.hasPrivateKey") Boolean certificatehasPrivateKey, @Query("certificate.nonce") String certificatenonce, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates list" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates generateVerificationCode" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates/{certificateName}/generateVerificationCode")
        Observable<Response<ResponseBody>> generateVerificationCode(@Path("certificateName") String certificateName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Header("If-Match") String ifMatch, @Query("certificate.name") String certificatename, @Query("certificate.rawBytes") String certificaterawBytes, @Query("certificate.isVerified") Boolean certificateisVerified, @Query("certificate.purpose") CertificatePurpose certificatepurpose, @Query("certificate.created") DateTime certificatecreated, @Query("certificate.lastUpdated") DateTime certificatelastUpdated, @Query("certificate.hasPrivateKey") Boolean certificatehasPrivateKey, @Query("certificate.nonce") String certificatenonce, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.DpsCertificates verifyCertificate" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/certificates/{certificateName}/verify")
        Observable<Response<ResponseBody>> verifyCertificate(@Path("certificateName") String certificateName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Header("If-Match") String ifMatch, @Query("certificate.name") String certificatename, @Query("certificate.rawBytes") String certificaterawBytes, @Query("certificate.isVerified") Boolean certificateisVerified, @Query("certificate.purpose") CertificatePurpose certificatepurpose, @Query("certificate.created") DateTime certificatecreated, @Query("certificate.lastUpdated") DateTime certificatelastUpdated, @Query("certificate.hasPrivateKey") Boolean certificatehasPrivateKey, @Query("certificate.nonce") String certificatenonce, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body VerificationCodeRequest request, @Header("User-Agent") String userAgent);

    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner get(String certificateName, String resourceGroupName, String provisioningServiceName) {
        return getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName).toBlocking().single().body();
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> getAsync(String certificateName, String resourceGroupName, String provisioningServiceName, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName), serviceCallback);
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> getAsync(String certificateName, String resourceGroupName, String provisioningServiceName) {
        return getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> getWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String ifMatch = null;
        return service.get(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner get(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).toBlocking().single().body();
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @param ifMatch ETag of the certificate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> getAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch), serviceCallback);
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> getAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return getWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the certificate from the provisioning service.
     *
     * @param certificateName Name of the certificate to retrieve.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of the provisioning service the certificate is associated with.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> getWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateResponseInner> getDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CertificateResponseInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CertificateResponseInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner createOrUpdate(String resourceGroupName, String provisioningServiceName, String certificateName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName).toBlocking().single().body();
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, String certificateName, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName), serviceCallback);
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, String certificateName) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, String certificateName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String ifMatch = null;
        final String certificate = null;
        CertificateBodyDescription certificateDescription = new CertificateBodyDescription();
        certificateDescription.withCertificate(null);
        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, certificateName, this.client.apiVersion(), ifMatch, this.client.acceptLanguage(), certificateDescription, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificate Base-64 representation of the X509 leaf certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner createOrUpdate(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificate) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificate).toBlocking().single().body();
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificate Base-64 representation of the X509 leaf certificate .cer file or just .pem file content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificate, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificate), serviceCallback);
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificate Base-64 representation of the X509 leaf certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificate) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificate).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Upload the certificate to the provisioning service.
     * Add new certificate or update an existing certificate.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName The name of the certificate create or update.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificate Base-64 representation of the X509 leaf certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificate) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        CertificateBodyDescription certificateDescription = new CertificateBodyDescription();
        certificateDescription.withCertificate(certificate);
        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, certificateName, this.client.apiVersion(), ifMatch, this.client.acceptLanguage(), certificateDescription, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = createOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateResponseInner> createOrUpdateDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CertificateResponseInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CertificateResponseInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch) {
        deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch).toBlocking().single().body();
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch), serviceCallback);
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch) {
        return deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String certificatename = null;
        final byte[] certificaterawBytes = new byte[0];
        final Boolean certificateisVerified = null;
        final CertificatePurpose certificatepurpose = null;
        final DateTime certificatecreated = null;
        final DateTime certificatelastUpdated = null;
        final Boolean certificatehasPrivateKey = null;
        final String certificatenonce = null;
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.delete(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @param certificatename This is optional, and it is the Common Name of the certificate.
     * @param certificaterawBytes Raw data within the certificate.
     * @param certificateisVerified Indicates if certificate has been verified by owner of the private key.
     * @param certificatepurpose A description that mentions the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Time the certificate is created.
     * @param certificatelastUpdated Time the certificate is last updated.
     * @param certificatehasPrivateKey Indicates if the certificate contains a private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce).toBlocking().single().body();
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @param certificatename This is optional, and it is the Common Name of the certificate.
     * @param certificaterawBytes Raw data within the certificate.
     * @param certificateisVerified Indicates if certificate has been verified by owner of the private key.
     * @param certificatepurpose A description that mentions the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Time the certificate is created.
     * @param certificatelastUpdated Time the certificate is last updated.
     * @param certificatehasPrivateKey Indicates if the certificate contains a private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce), serviceCallback);
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @param certificatename This is optional, and it is the Common Name of the certificate.
     * @param certificaterawBytes Raw data within the certificate.
     * @param certificateisVerified Indicates if certificate has been verified by owner of the private key.
     * @param certificatepurpose A description that mentions the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Time the certificate is created.
     * @param certificatelastUpdated Time the certificate is last updated.
     * @param certificatehasPrivateKey Indicates if the certificate contains a private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        return deleteWithServiceResponseAsync(resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the Provisioning Service Certificate.
     * Deletes the specified certificate assosciated with the Provisioning Service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName The name of the provisioning service.
     * @param certificateName This is a mandatory field, and is the logical name of the certificate that the provisioning service will access by.
     * @param ifMatch ETag of the certificate
     * @param certificatename This is optional, and it is the Common Name of the certificate.
     * @param certificaterawBytes Raw data within the certificate.
     * @param certificateisVerified Indicates if certificate has been verified by owner of the private key.
     * @param certificatepurpose A description that mentions the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Time the certificate is created.
     * @param certificatelastUpdated Time the certificate is last updated.
     * @param certificatehasPrivateKey Indicates if the certificate contains a private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, String certificateName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.delete(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, certificateName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get all the certificates tied to the provisioning service.
     *
     * @param resourceGroupName Name of resource group.
     * @param provisioningServiceName Name of provisioning service to retrieve certificates for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateListDescriptionInner object if successful.
     */
    public CertificateListDescriptionInner list(String resourceGroupName, String provisioningServiceName) {
        return listWithServiceResponseAsync(resourceGroupName, provisioningServiceName).toBlocking().single().body();
    }

    /**
     * Get all the certificates tied to the provisioning service.
     *
     * @param resourceGroupName Name of resource group.
     * @param provisioningServiceName Name of provisioning service to retrieve certificates for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateListDescriptionInner> listAsync(String resourceGroupName, String provisioningServiceName, final ServiceCallback<CertificateListDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listWithServiceResponseAsync(resourceGroupName, provisioningServiceName), serviceCallback);
    }

    /**
     * Get all the certificates tied to the provisioning service.
     *
     * @param resourceGroupName Name of resource group.
     * @param provisioningServiceName Name of provisioning service to retrieve certificates for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateListDescriptionInner object
     */
    public Observable<CertificateListDescriptionInner> listAsync(String resourceGroupName, String provisioningServiceName) {
        return listWithServiceResponseAsync(resourceGroupName, provisioningServiceName).map(new Func1<ServiceResponse<CertificateListDescriptionInner>, CertificateListDescriptionInner>() {
            @Override
            public CertificateListDescriptionInner call(ServiceResponse<CertificateListDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get all the certificates tied to the provisioning service.
     *
     * @param resourceGroupName Name of resource group.
     * @param provisioningServiceName Name of provisioning service to retrieve certificates for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateListDescriptionInner object
     */
    public Observable<ServiceResponse<CertificateListDescriptionInner>> listWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateListDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateListDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateListDescriptionInner> clientResponse = listDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateListDescriptionInner> listDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CertificateListDescriptionInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CertificateListDescriptionInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VerificationCodeResponseInner object if successful.
     */
    public VerificationCodeResponseInner generateVerificationCode(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).toBlocking().single().body();
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VerificationCodeResponseInner> generateVerificationCodeAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, final ServiceCallback<VerificationCodeResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch), serviceCallback);
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VerificationCodeResponseInner object
     */
    public Observable<VerificationCodeResponseInner> generateVerificationCodeAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).map(new Func1<ServiceResponse<VerificationCodeResponseInner>, VerificationCodeResponseInner>() {
            @Override
            public VerificationCodeResponseInner call(ServiceResponse<VerificationCodeResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VerificationCodeResponseInner object
     */
    public Observable<ServiceResponse<VerificationCodeResponseInner>> generateVerificationCodeWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String certificatename = null;
        final byte[] certificaterawBytes = new byte[0];
        final Boolean certificateisVerified = null;
        final CertificatePurpose certificatepurpose = null;
        final DateTime certificatecreated = null;
        final DateTime certificatelastUpdated = null;
        final Boolean certificatehasPrivateKey = null;
        final String certificatenonce = null;
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.generateVerificationCode(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VerificationCodeResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<VerificationCodeResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VerificationCodeResponseInner> clientResponse = generateVerificationCodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Description mentioning the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the VerificationCodeResponseInner object if successful.
     */
    public VerificationCodeResponseInner generateVerificationCode(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        return generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce).toBlocking().single().body();
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Description mentioning the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<VerificationCodeResponseInner> generateVerificationCodeAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, final ServiceCallback<VerificationCodeResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce), serviceCallback);
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Description mentioning the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VerificationCodeResponseInner object
     */
    public Observable<VerificationCodeResponseInner> generateVerificationCodeAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        return generateVerificationCodeWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce).map(new Func1<ServiceResponse<VerificationCodeResponseInner>, VerificationCodeResponseInner>() {
            @Override
            public VerificationCodeResponseInner call(ServiceResponse<VerificationCodeResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Generate verification code for Proof of Possession.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName name of resource group.
     * @param provisioningServiceName Name of provisioning service.
     * @param ifMatch ETag of the certificate. This is required to update an existing certificate, and ignored while creating a brand new certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Description mentioning the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the VerificationCodeResponseInner object
     */
    public Observable<ServiceResponse<VerificationCodeResponseInner>> generateVerificationCodeWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.generateVerificationCode(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VerificationCodeResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<VerificationCodeResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VerificationCodeResponseInner> clientResponse = generateVerificationCodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VerificationCodeResponseInner> generateVerificationCodeDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<VerificationCodeResponseInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<VerificationCodeResponseInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner verifyCertificate(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).toBlocking().single().body();
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> verifyCertificateAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch), serviceCallback);
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> verifyCertificateAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        return verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> verifyCertificateWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String certificatename = null;
        final byte[] certificaterawBytes = new byte[0];
        final Boolean certificateisVerified = null;
        final CertificatePurpose certificatepurpose = null;
        final DateTime certificatecreated = null;
        final DateTime certificatelastUpdated = null;
        final Boolean certificatehasPrivateKey = null;
        final String certificatenonce = null;
        final String certificate = null;
        VerificationCodeRequest request = new VerificationCodeRequest();
        request.withCertificate(null);
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.verifyCertificate(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), request, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = verifyCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Describe the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param certificate base-64 representation of X509 certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CertificateResponseInner object if successful.
     */
    public CertificateResponseInner verifyCertificate(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, String certificate) {
        return verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, certificate).toBlocking().single().body();
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Describe the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param certificate base-64 representation of X509 certificate .cer file or just .pem file content.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CertificateResponseInner> verifyCertificateAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, String certificate, final ServiceCallback<CertificateResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, certificate), serviceCallback);
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Describe the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param certificate base-64 representation of X509 certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<CertificateResponseInner> verifyCertificateAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, String certificate) {
        return verifyCertificateWithServiceResponseAsync(certificateName, resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytes, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, certificate).map(new Func1<ServiceResponse<CertificateResponseInner>, CertificateResponseInner>() {
            @Override
            public CertificateResponseInner call(ServiceResponse<CertificateResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Verify certificate's private key possession.
     * Verifies the certificate's private key possession by providing the leaf cert issued by the verifying pre uploaded certificate.
     *
     * @param certificateName The mandatory logical name of the certificate, that the provisioning service uses to access.
     * @param resourceGroupName Resource group name.
     * @param provisioningServiceName Provisioning service name.
     * @param ifMatch ETag of the certificate.
     * @param certificatename Common Name for the certificate.
     * @param certificaterawBytes Raw data of certificate.
     * @param certificateisVerified Indicates if the certificate has been verified by owner of the private key.
     * @param certificatepurpose Describe the purpose of the certificate. Possible values include: 'clientAuthentication', 'serverAuthentication'
     * @param certificatecreated Certificate creation time.
     * @param certificatelastUpdated Certificate last updated time.
     * @param certificatehasPrivateKey Indicates if the certificate contains private key.
     * @param certificatenonce Random number generated to indicate Proof of Possession.
     * @param certificate base-64 representation of X509 certificate .cer file or just .pem file content.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CertificateResponseInner object
     */
    public Observable<ServiceResponse<CertificateResponseInner>> verifyCertificateWithServiceResponseAsync(String certificateName, String resourceGroupName, String provisioningServiceName, String ifMatch, String certificatename, byte[] certificaterawBytes, Boolean certificateisVerified, CertificatePurpose certificatepurpose, DateTime certificatecreated, DateTime certificatelastUpdated, Boolean certificatehasPrivateKey, String certificatenonce, String certificate) {
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (ifMatch == null) {
            throw new IllegalArgumentException("Parameter ifMatch is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        VerificationCodeRequest request = new VerificationCodeRequest();
        request.withCertificate(certificate);
        String certificaterawBytesConverted = Base64.encodeBase64String(certificaterawBytes);
        return service.verifyCertificate(certificateName, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, ifMatch, certificatename, certificaterawBytesConverted, certificateisVerified, certificatepurpose, certificatecreated, certificatelastUpdated, certificatehasPrivateKey, certificatenonce, this.client.apiVersion(), this.client.acceptLanguage(), request, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CertificateResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<CertificateResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CertificateResponseInner> clientResponse = verifyCertificateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CertificateResponseInner> verifyCertificateDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<CertificateResponseInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CertificateResponseInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

}
