/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.provisioningservices.implementation;

import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsGet;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsDelete;
import com.microsoft.azure.management.resources.fluentcore.collection.InnerSupportsListing;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.provisioningservices.ErrorDetailsException;
import com.microsoft.azure.management.provisioningservices.OperationInputs;
import com.microsoft.azure.management.provisioningservices.TagsResource;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in IotDpsResources.
 */
public class IotDpsResourcesInner implements InnerSupportsGet<ProvisioningServiceDescriptionInner>, InnerSupportsDelete<Void>, InnerSupportsListing<ProvisioningServiceDescriptionInner> {
    /** The Retrofit service to perform REST calls. */
    private IotDpsResourcesService service;
    /** The service client containing this operation class. */
    private IotDpsClientImpl client;

    /**
     * Initializes an instance of IotDpsResourcesInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public IotDpsResourcesInner(Retrofit retrofit, IotDpsClientImpl client) {
        this.service = retrofit.create(IotDpsResourcesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for IotDpsResources to be
     * used by Retrofit to perform actually REST calls.
     */
    interface IotDpsResourcesService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources getByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}")
        Observable<Response<ResponseBody>> getByResourceGroup(@Path("provisioningServiceName") String provisioningServiceName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources createOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Body ProvisioningServiceDescriptionInner iotDpsDescription, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources beginCreateOrUpdate" })
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Body ProvisioningServiceDescriptionInner iotDpsDescription, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources update" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}")
        Observable<Response<ResponseBody>> update(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TagsResource provisioningServiceTags, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources beginUpdate" })
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}")
        Observable<Response<ResponseBody>> beginUpdate(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body TagsResource provisioningServiceTags, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources delete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("provisioningServiceName") String provisioningServiceName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources beginDelete" })
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> beginDelete(@Path("provisioningServiceName") String provisioningServiceName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources list" })
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Devices/provisioningServices")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listByResourceGroup" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources getOperationResult" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getOperationResult(@Path("operationId") String operationId, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Path("provisioningServiceName") String provisioningServiceName, @Query("asyncinfo") String asyncinfo, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listValidSkus" })
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/skus")
        Observable<Response<ResponseBody>> listValidSkus(@Path("provisioningServiceName") String provisioningServiceName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources checkProvisioningServiceNameAvailability" })
        @POST("subscriptions/{subscriptionId}/providers/Microsoft.Devices/checkProvisioningServiceNameAvailability")
        Observable<Response<ResponseBody>> checkProvisioningServiceNameAvailability(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body OperationInputs arguments, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listKeys" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/listkeys")
        Observable<Response<ResponseBody>> listKeys(@Path("provisioningServiceName") String provisioningServiceName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listKeysForKeyName" })
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/provisioningServices/{provisioningServiceName}/keys/{keyName}/listkeys")
        Observable<Response<ResponseBody>> listKeysForKeyName(@Path("provisioningServiceName") String provisioningServiceName, @Path("keyName") String keyName, @Path("subscriptionId") String subscriptionId, @Path("resourceGroupName") String resourceGroupName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listByResourceGroupNext" })
        @GET
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listValidSkusNext" })
        @GET
        Observable<Response<ResponseBody>> listValidSkusNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.provisioningservices.IotDpsResources listKeysNext" })
        @GET
        Observable<Response<ResponseBody>> listKeysNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get the non-security related metadata of the provisioning service.
     * Get the metadata of the provisioning service without SAS keys.
     *
     * @param provisioningServiceName Name of the provisioning service to retrieve.
     * @param resourceGroupName Resource group name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner getByResourceGroup(String provisioningServiceName, String resourceGroupName) {
        return getByResourceGroupWithServiceResponseAsync(provisioningServiceName, resourceGroupName).toBlocking().single().body();
    }

    /**
     * Get the non-security related metadata of the provisioning service.
     * Get the metadata of the provisioning service without SAS keys.
     *
     * @param provisioningServiceName Name of the provisioning service to retrieve.
     * @param resourceGroupName Resource group name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> getByResourceGroupAsync(String provisioningServiceName, String resourceGroupName, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(provisioningServiceName, resourceGroupName), serviceCallback);
    }

    /**
     * Get the non-security related metadata of the provisioning service.
     * Get the metadata of the provisioning service without SAS keys.
     *
     * @param provisioningServiceName Name of the provisioning service to retrieve.
     * @param resourceGroupName Resource group name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ProvisioningServiceDescriptionInner> getByResourceGroupAsync(String provisioningServiceName, String resourceGroupName) {
        return getByResourceGroupWithServiceResponseAsync(provisioningServiceName, resourceGroupName).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the non-security related metadata of the provisioning service.
     * Get the metadata of the provisioning service without SAS keys.
     *
     * @param provisioningServiceName Name of the provisioning service to retrieve.
     * @param resourceGroupName Resource group name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> getByResourceGroupWithServiceResponseAsync(String provisioningServiceName, String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getByResourceGroup(provisioningServiceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProvisioningServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProvisioningServiceDescriptionInner> clientResponse = getByResourceGroupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProvisioningServiceDescriptionInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProvisioningServiceDescriptionInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner createOrUpdate(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription).toBlocking().last().body();
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription), serviceCallback);
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ProvisioningServiceDescriptionInner> createOrUpdateAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (iotDpsDescription == null) {
            throw new IllegalArgumentException("Parameter iotDpsDescription is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(iotDpsDescription);
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, iotDpsDescription, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType());
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner beginCreateOrUpdate(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription).toBlocking().single().body();
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> beginCreateOrUpdateAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription), serviceCallback);
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ProvisioningServiceDescriptionInner> beginCreateOrUpdateAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, iotDpsDescription).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create or update the metadata of the provisioning service.
     * Create or update the metadata of the provisioning service. The usual pattern to modify a property is to retrieve the provisioning service metadata and security metadata, and then combine them with the modified values in a new body to update the provisioning service.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param iotDpsDescription Description of the provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, ProvisioningServiceDescriptionInner iotDpsDescription) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (iotDpsDescription == null) {
            throw new IllegalArgumentException("Parameter iotDpsDescription is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(iotDpsDescription);
        return service.beginCreateOrUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, iotDpsDescription, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProvisioningServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProvisioningServiceDescriptionInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProvisioningServiceDescriptionInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProvisioningServiceDescriptionInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType())
                .register(201, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner update(String resourceGroupName, String provisioningServiceName) {
        return updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName).toBlocking().last().body();
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> updateAsync(String resourceGroupName, String provisioningServiceName, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName), serviceCallback);
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ProvisioningServiceDescriptionInner> updateAsync(String resourceGroupName, String provisioningServiceName) {
        return updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> updateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Map<String, String> tags = null;
        TagsResource provisioningServiceTags = new TagsResource();
        provisioningServiceTags.withTags(null);
        Observable<Response<ResponseBody>> observable = service.update(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, this.client.apiVersion(), this.client.acceptLanguage(), provisioningServiceTags, this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType());
    }
    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner update(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        return updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags).toBlocking().last().body();
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> updateAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags), serviceCallback);
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ProvisioningServiceDescriptionInner> updateAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        return updateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> updateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(tags);
        TagsResource provisioningServiceTags = new TagsResource();
        provisioningServiceTags.withTags(tags);
        Observable<Response<ResponseBody>> observable = service.update(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, this.client.apiVersion(), this.client.acceptLanguage(), provisioningServiceTags, this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType());
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner beginUpdate(String resourceGroupName, String provisioningServiceName) {
        return beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName).toBlocking().single().body();
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> beginUpdateAsync(String resourceGroupName, String provisioningServiceName, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName), serviceCallback);
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ProvisioningServiceDescriptionInner> beginUpdateAsync(String resourceGroupName, String provisioningServiceName) {
        return beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> beginUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Map<String, String> tags = null;
        TagsResource provisioningServiceTags = new TagsResource();
        provisioningServiceTags.withTags(null);
        return service.beginUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, this.client.apiVersion(), this.client.acceptLanguage(), provisioningServiceTags, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProvisioningServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProvisioningServiceDescriptionInner> clientResponse = beginUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProvisioningServiceDescriptionInner object if successful.
     */
    public ProvisioningServiceDescriptionInner beginUpdate(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        return beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags).toBlocking().single().body();
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProvisioningServiceDescriptionInner> beginUpdateAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags, final ServiceCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags), serviceCallback);
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ProvisioningServiceDescriptionInner> beginUpdateAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        return beginUpdateWithServiceResponseAsync(resourceGroupName, provisioningServiceName, tags).map(new Func1<ServiceResponse<ProvisioningServiceDescriptionInner>, ProvisioningServiceDescriptionInner>() {
            @Override
            public ProvisioningServiceDescriptionInner call(ServiceResponse<ProvisioningServiceDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update an existing provisioning service's tags.
     * Update an existing provisioning service's tags. to update other fields use the CreateOrUpdate method.
     *
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service to create or update.
     * @param tags Resource tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProvisioningServiceDescriptionInner object
     */
    public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> beginUpdateWithServiceResponseAsync(String resourceGroupName, String provisioningServiceName, Map<String, String> tags) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(tags);
        TagsResource provisioningServiceTags = new TagsResource();
        provisioningServiceTags.withTags(tags);
        return service.beginUpdate(this.client.subscriptionId(), resourceGroupName, provisioningServiceName, this.client.apiVersion(), this.client.acceptLanguage(), provisioningServiceTags, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProvisioningServiceDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<ProvisioningServiceDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProvisioningServiceDescriptionInner> clientResponse = beginUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProvisioningServiceDescriptionInner> beginUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProvisioningServiceDescriptionInner, CloudException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ProvisioningServiceDescriptionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void delete(String provisioningServiceName, String resourceGroupName) {
        deleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName).toBlocking().last().body();
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsync(String provisioningServiceName, String resourceGroupName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName), serviceCallback);
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<Void> deleteAsync(String provisioningServiceName, String resourceGroupName) {
        return deleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String provisioningServiceName, String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Observable<Response<ResponseBody>> observable = service.delete(provisioningServiceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Void>() { }.getType());
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete(String provisioningServiceName, String resourceGroupName) {
        beginDeleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName).toBlocking().single().body();
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsync(String provisioningServiceName, String resourceGroupName, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(beginDeleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName), serviceCallback);
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> beginDeleteAsync(String provisioningServiceName, String resourceGroupName) {
        return beginDeleteWithServiceResponseAsync(provisioningServiceName, resourceGroupName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete the Provisioning Service.
     * Deletes the Provisioning Service.
     *
     * @param provisioningServiceName Name of provisioning service to delete.
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> beginDeleteWithServiceResponseAsync(String provisioningServiceName, String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(provisioningServiceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> beginDeleteDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object if successful.
     */
    public PagedList<ProvisioningServiceDescriptionInner> list() {
        ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<ProvisioningServiceDescriptionInner>(response.body()) {
            @Override
            public Page<ProvisioningServiceDescriptionInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProvisioningServiceDescriptionInner>> listAsync(final ListOperationCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<Page<ProvisioningServiceDescriptionInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Page<ProvisioningServiceDescriptionInner>>() {
                @Override
                public Page<ProvisioningServiceDescriptionInner> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProvisioningServiceDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> listDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProvisioningServiceDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProvisioningServiceDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object if successful.
     */
    public PagedList<ProvisioningServiceDescriptionInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<ProvisioningServiceDescriptionInner>(response.body()) {
            @Override
            public Page<ProvisioningServiceDescriptionInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param resourceGroupName Resource group identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProvisioningServiceDescriptionInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<Page<ProvisioningServiceDescriptionInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Page<ProvisioningServiceDescriptionInner>>() {
                @Override
                public Page<ProvisioningServiceDescriptionInner> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
    ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> * @param resourceGroupName Resource group identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProvisioningServiceDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProvisioningServiceDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProvisioningServiceDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Gets the status of a long running operation, such as create, update or delete a provisioning service.
     *
     * @param operationId Operation id corresponding to long running operation. Use this to poll for the status.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service that the operation is running on.
     * @param asyncinfo Async header used to poll on the status of the operation, obtained while creating the long running operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the AsyncOperationResultInner object if successful.
     */
    public AsyncOperationResultInner getOperationResult(String operationId, String resourceGroupName, String provisioningServiceName, String asyncinfo) {
        return getOperationResultWithServiceResponseAsync(operationId, resourceGroupName, provisioningServiceName, asyncinfo).toBlocking().single().body();
    }

    /**
     * Gets the status of a long running operation, such as create, update or delete a provisioning service.
     *
     * @param operationId Operation id corresponding to long running operation. Use this to poll for the status.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service that the operation is running on.
     * @param asyncinfo Async header used to poll on the status of the operation, obtained while creating the long running operation.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<AsyncOperationResultInner> getOperationResultAsync(String operationId, String resourceGroupName, String provisioningServiceName, String asyncinfo, final ServiceCallback<AsyncOperationResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(getOperationResultWithServiceResponseAsync(operationId, resourceGroupName, provisioningServiceName, asyncinfo), serviceCallback);
    }

    /**
     * Gets the status of a long running operation, such as create, update or delete a provisioning service.
     *
     * @param operationId Operation id corresponding to long running operation. Use this to poll for the status.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service that the operation is running on.
     * @param asyncinfo Async header used to poll on the status of the operation, obtained while creating the long running operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AsyncOperationResultInner object
     */
    public Observable<AsyncOperationResultInner> getOperationResultAsync(String operationId, String resourceGroupName, String provisioningServiceName, String asyncinfo) {
        return getOperationResultWithServiceResponseAsync(operationId, resourceGroupName, provisioningServiceName, asyncinfo).map(new Func1<ServiceResponse<AsyncOperationResultInner>, AsyncOperationResultInner>() {
            @Override
            public AsyncOperationResultInner call(ServiceResponse<AsyncOperationResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the status of a long running operation, such as create, update or delete a provisioning service.
     *
     * @param operationId Operation id corresponding to long running operation. Use this to poll for the status.
     * @param resourceGroupName Resource group identifier.
     * @param provisioningServiceName Name of provisioning service that the operation is running on.
     * @param asyncinfo Async header used to poll on the status of the operation, obtained while creating the long running operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the AsyncOperationResultInner object
     */
    public Observable<ServiceResponse<AsyncOperationResultInner>> getOperationResultWithServiceResponseAsync(String operationId, String resourceGroupName, String provisioningServiceName, String asyncinfo) {
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (asyncinfo == null) {
            throw new IllegalArgumentException("Parameter asyncinfo is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getOperationResult(operationId, this.client.subscriptionId(), resourceGroupName, provisioningServiceName, asyncinfo, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AsyncOperationResultInner>>>() {
                @Override
                public Observable<ServiceResponse<AsyncOperationResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AsyncOperationResultInner> clientResponse = getOperationResultDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AsyncOperationResultInner> getOperationResultDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<AsyncOperationResultInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<AsyncOperationResultInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param provisioningServiceName Name of provisioning service.
     * @param resourceGroupName Name of resource group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IotDpsSkuDefinitionInner&gt; object if successful.
     */
    public PagedList<IotDpsSkuDefinitionInner> listValidSkus(final String provisioningServiceName, final String resourceGroupName) {
        ServiceResponse<Page<IotDpsSkuDefinitionInner>> response = listValidSkusSinglePageAsync(provisioningServiceName, resourceGroupName).toBlocking().single();
        return new PagedList<IotDpsSkuDefinitionInner>(response.body()) {
            @Override
            public Page<IotDpsSkuDefinitionInner> nextPage(String nextPageLink) {
                return listValidSkusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param provisioningServiceName Name of provisioning service.
     * @param resourceGroupName Name of resource group.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IotDpsSkuDefinitionInner>> listValidSkusAsync(final String provisioningServiceName, final String resourceGroupName, final ListOperationCallback<IotDpsSkuDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listValidSkusSinglePageAsync(provisioningServiceName, resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(String nextPageLink) {
                    return listValidSkusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param provisioningServiceName Name of provisioning service.
     * @param resourceGroupName Name of resource group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IotDpsSkuDefinitionInner&gt; object
     */
    public Observable<Page<IotDpsSkuDefinitionInner>> listValidSkusAsync(final String provisioningServiceName, final String resourceGroupName) {
        return listValidSkusWithServiceResponseAsync(provisioningServiceName, resourceGroupName)
            .map(new Func1<ServiceResponse<Page<IotDpsSkuDefinitionInner>>, Page<IotDpsSkuDefinitionInner>>() {
                @Override
                public Page<IotDpsSkuDefinitionInner> call(ServiceResponse<Page<IotDpsSkuDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param provisioningServiceName Name of provisioning service.
     * @param resourceGroupName Name of resource group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IotDpsSkuDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> listValidSkusWithServiceResponseAsync(final String provisioningServiceName, final String resourceGroupName) {
        return listValidSkusSinglePageAsync(provisioningServiceName, resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<IotDpsSkuDefinitionInner>>, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(ServiceResponse<Page<IotDpsSkuDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listValidSkusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
    ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> * @param provisioningServiceName Name of provisioning service.
    ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> * @param resourceGroupName Name of resource group.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IotDpsSkuDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> listValidSkusSinglePageAsync(final String provisioningServiceName, final String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listValidSkus(provisioningServiceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> result = listValidSkusDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IotDpsSkuDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> listValidSkusDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IotDpsSkuDefinitionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IotDpsSkuDefinitionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Check if a provisioning service name is available.
     * Check if a provisioning service name is available. This will validate if the name is syntactically valid and if the name is usable.
     *
     * @param name The name of the Provisioning Service to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the NameAvailabilityInfoInner object if successful.
     */
    public NameAvailabilityInfoInner checkProvisioningServiceNameAvailability(String name) {
        return checkProvisioningServiceNameAvailabilityWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Check if a provisioning service name is available.
     * Check if a provisioning service name is available. This will validate if the name is syntactically valid and if the name is usable.
     *
     * @param name The name of the Provisioning Service to check.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<NameAvailabilityInfoInner> checkProvisioningServiceNameAvailabilityAsync(String name, final ServiceCallback<NameAvailabilityInfoInner> serviceCallback) {
        return ServiceFuture.fromResponse(checkProvisioningServiceNameAvailabilityWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Check if a provisioning service name is available.
     * Check if a provisioning service name is available. This will validate if the name is syntactically valid and if the name is usable.
     *
     * @param name The name of the Provisioning Service to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityInfoInner object
     */
    public Observable<NameAvailabilityInfoInner> checkProvisioningServiceNameAvailabilityAsync(String name) {
        return checkProvisioningServiceNameAvailabilityWithServiceResponseAsync(name).map(new Func1<ServiceResponse<NameAvailabilityInfoInner>, NameAvailabilityInfoInner>() {
            @Override
            public NameAvailabilityInfoInner call(ServiceResponse<NameAvailabilityInfoInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Check if a provisioning service name is available.
     * Check if a provisioning service name is available. This will validate if the name is syntactically valid and if the name is usable.
     *
     * @param name The name of the Provisioning Service to check.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the NameAvailabilityInfoInner object
     */
    public Observable<ServiceResponse<NameAvailabilityInfoInner>> checkProvisioningServiceNameAvailabilityWithServiceResponseAsync(String name) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        OperationInputs arguments = new OperationInputs();
        arguments.withName(name);
        return service.checkProvisioningServiceNameAvailability(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), arguments, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NameAvailabilityInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<NameAvailabilityInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NameAvailabilityInfoInner> clientResponse = checkProvisioningServiceNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NameAvailabilityInfoInner> checkProvisioningServiceNameAvailabilityDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<NameAvailabilityInfoInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<NameAvailabilityInfoInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param provisioningServiceName The provisioning service name to get the shared access keys for.
     * @param resourceGroupName resource group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object if successful.
     */
    public PagedList<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> listKeys(final String provisioningServiceName, final String resourceGroupName) {
        ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> response = listKeysSinglePageAsync(provisioningServiceName, resourceGroupName).toBlocking().single();
        return new PagedList<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>(response.body()) {
            @Override
            public Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> nextPage(String nextPageLink) {
                return listKeysNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param provisioningServiceName The provisioning service name to get the shared access keys for.
     * @param resourceGroupName resource group name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysAsync(final String provisioningServiceName, final String resourceGroupName, final ListOperationCallback<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listKeysSinglePageAsync(provisioningServiceName, resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(String nextPageLink) {
                    return listKeysNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param provisioningServiceName The provisioning service name to get the shared access keys for.
     * @param resourceGroupName resource group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object
     */
    public Observable<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysAsync(final String provisioningServiceName, final String resourceGroupName) {
        return listKeysWithServiceResponseAsync(provisioningServiceName, resourceGroupName)
            .map(new Func1<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>, Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>() {
                @Override
                public Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> call(ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param provisioningServiceName The provisioning service name to get the shared access keys for.
     * @param resourceGroupName resource group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> listKeysWithServiceResponseAsync(final String provisioningServiceName, final String resourceGroupName) {
        return listKeysSinglePageAsync(provisioningServiceName, resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listKeysNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
    ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> * @param provisioningServiceName The provisioning service name to get the shared access keys for.
    ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> * @param resourceGroupName resource group name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> listKeysSinglePageAsync(final String provisioningServiceName, final String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listKeys(provisioningServiceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> result = listKeysDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get a shared access policy by name from a provisioning service.
     * List primary and secondary keys for a specific key name.
     *
     * @param provisioningServiceName Name of the provisioning service.
     * @param keyName Logical key name to get key-values for.
     * @param resourceGroupName The name of the resource group that contains the provisioning service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner object if successful.
     */
    public SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner listKeysForKeyName(String provisioningServiceName, String keyName, String resourceGroupName) {
        return listKeysForKeyNameWithServiceResponseAsync(provisioningServiceName, keyName, resourceGroupName).toBlocking().single().body();
    }

    /**
     * Get a shared access policy by name from a provisioning service.
     * List primary and secondary keys for a specific key name.
     *
     * @param provisioningServiceName Name of the provisioning service.
     * @param keyName Logical key name to get key-values for.
     * @param resourceGroupName The name of the resource group that contains the provisioning service.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> listKeysForKeyNameAsync(String provisioningServiceName, String keyName, String resourceGroupName, final ServiceCallback<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> serviceCallback) {
        return ServiceFuture.fromResponse(listKeysForKeyNameWithServiceResponseAsync(provisioningServiceName, keyName, resourceGroupName), serviceCallback);
    }

    /**
     * Get a shared access policy by name from a provisioning service.
     * List primary and secondary keys for a specific key name.
     *
     * @param provisioningServiceName Name of the provisioning service.
     * @param keyName Logical key name to get key-values for.
     * @param resourceGroupName The name of the resource group that contains the provisioning service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner object
     */
    public Observable<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> listKeysForKeyNameAsync(String provisioningServiceName, String keyName, String resourceGroupName) {
        return listKeysForKeyNameWithServiceResponseAsync(provisioningServiceName, keyName, resourceGroupName).map(new Func1<ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>, SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>() {
            @Override
            public SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner call(ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a shared access policy by name from a provisioning service.
     * List primary and secondary keys for a specific key name.
     *
     * @param provisioningServiceName Name of the provisioning service.
     * @param keyName Logical key name to get key-values for.
     * @param resourceGroupName The name of the resource group that contains the provisioning service.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner object
     */
    public Observable<ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysForKeyNameWithServiceResponseAsync(String provisioningServiceName, String keyName, String resourceGroupName) {
        if (provisioningServiceName == null) {
            throw new IllegalArgumentException("Parameter provisioningServiceName is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listKeysForKeyName(provisioningServiceName, keyName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>() {
                @Override
                public Observable<ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> clientResponse = listKeysForKeyNameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> listKeysForKeyNameDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object if successful.
     */
    public PagedList<ProvisioningServiceDescriptionInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProvisioningServiceDescriptionInner>(response.body()) {
            @Override
            public Page<ProvisioningServiceDescriptionInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProvisioningServiceDescriptionInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<ProvisioningServiceDescriptionInner>> serviceFuture, final ListOperationCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<Page<ProvisioningServiceDescriptionInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Page<ProvisioningServiceDescriptionInner>>() {
                @Override
                public Page<ProvisioningServiceDescriptionInner> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get all the provisioning services in a subscription.
     * List all the provisioning services for a given subscription id.
     *
    ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProvisioningServiceDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> listNextDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProvisioningServiceDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProvisioningServiceDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object if successful.
     */
    public PagedList<ProvisioningServiceDescriptionInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ProvisioningServiceDescriptionInner>(response.body()) {
            @Override
            public Page<ProvisioningServiceDescriptionInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProvisioningServiceDescriptionInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceFuture<List<ProvisioningServiceDescriptionInner>> serviceFuture, final ListOperationCallback<ProvisioningServiceDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<Page<ProvisioningServiceDescriptionInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Page<ProvisioningServiceDescriptionInner>>() {
                @Override
                public Page<ProvisioningServiceDescriptionInner> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(ServiceResponse<Page<ProvisioningServiceDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get a list of all provisioning services in the given resource group.
     *
    ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ProvisioningServiceDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listByResourceGroupNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ProvisioningServiceDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ProvisioningServiceDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ProvisioningServiceDescriptionInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ProvisioningServiceDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ProvisioningServiceDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;IotDpsSkuDefinitionInner&gt; object if successful.
     */
    public PagedList<IotDpsSkuDefinitionInner> listValidSkusNext(final String nextPageLink) {
        ServiceResponse<Page<IotDpsSkuDefinitionInner>> response = listValidSkusNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<IotDpsSkuDefinitionInner>(response.body()) {
            @Override
            public Page<IotDpsSkuDefinitionInner> nextPage(String nextPageLink) {
                return listValidSkusNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IotDpsSkuDefinitionInner>> listValidSkusNextAsync(final String nextPageLink, final ServiceFuture<List<IotDpsSkuDefinitionInner>> serviceFuture, final ListOperationCallback<IotDpsSkuDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listValidSkusNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(String nextPageLink) {
                    return listValidSkusNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IotDpsSkuDefinitionInner&gt; object
     */
    public Observable<Page<IotDpsSkuDefinitionInner>> listValidSkusNextAsync(final String nextPageLink) {
        return listValidSkusNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<IotDpsSkuDefinitionInner>>, Page<IotDpsSkuDefinitionInner>>() {
                @Override
                public Page<IotDpsSkuDefinitionInner> call(ServiceResponse<Page<IotDpsSkuDefinitionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;IotDpsSkuDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> listValidSkusNextWithServiceResponseAsync(final String nextPageLink) {
        return listValidSkusNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<IotDpsSkuDefinitionInner>>, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(ServiceResponse<Page<IotDpsSkuDefinitionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listValidSkusNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the list of valid SKUs for a provisioning service.
     * Gets the list of valid SKUs and tiers for a provisioning service.
     *
    ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;IotDpsSkuDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> listValidSkusNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listValidSkusNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<IotDpsSkuDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> result = listValidSkusNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<IotDpsSkuDefinitionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<IotDpsSkuDefinitionInner>> listValidSkusNextDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<IotDpsSkuDefinitionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<IotDpsSkuDefinitionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorDetailsException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object if successful.
     */
    public PagedList<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> listKeysNext(final String nextPageLink) {
        ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> response = listKeysNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>(response.body()) {
            @Override
            public Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> nextPage(String nextPageLink) {
                return listKeysNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysNextAsync(final String nextPageLink, final ServiceFuture<List<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> serviceFuture, final ListOperationCallback<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listKeysNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(String nextPageLink) {
                    return listKeysNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object
     */
    public Observable<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysNextAsync(final String nextPageLink) {
        return listKeysNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>, Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>() {
                @Override
                public Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner> call(ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object
     */
    public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> listKeysNextWithServiceResponseAsync(final String nextPageLink) {
        return listKeysNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listKeysNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the security metadata for a provisioning service.
     * List the primary and secondary keys for a provisioning service.
     *
    ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> listKeysNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listKeysNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> result = listKeysNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>> listKeysNextDelegate(Response<ResponseBody> response) throws ErrorDetailsException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>, ErrorDetailsException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<SharedAccessSignatureAuthorizationRuleAccessRightsDescriptionInner>>() { }.getType())
                .registerError(ErrorDetailsException.class)
                .build(response);
    }

}
