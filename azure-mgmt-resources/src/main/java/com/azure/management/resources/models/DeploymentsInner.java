// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
// 
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.management.resources.models;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Head;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.management.CloudException;
import com.azure.core.util.polling.AsyncPollResponse;
import com.azure.management.resources.DeploymentWhatIf;
import com.azure.management.resources.ScopedDeployment;
import java.nio.ByteBuffer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in
 * Deployments.
 */
public final class DeploymentsInner {
    /**
     * The proxy service used to perform REST calls.
     */
    private DeploymentsService service;

    /**
     * The service client containing this operation class.
     */
    private ResourceManagementClientImpl client;

    /**
     * Initializes an instance of DeploymentsInner.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    public DeploymentsInner(ResourceManagementClientImpl client) {
        this.service = RestProxy.create(DeploymentsService.class, client.getHttpPipeline());
        this.client = client;
    }

    /**
     * The interface defining all the services for
     * ResourceManagementClientDeployments to be used by the proxy service to
     * perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "ResourceManagementClientDeployments")
    private interface DeploymentsService {
        @Delete("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Head("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({204, 404})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> checkExistenceAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Get("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> getAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> cancelAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate")
        @ExpectedResponses({200, 400})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Post("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Get("/{scope}/providers/Microsoft.Resources/deployments/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @QueryParam("api-version") String apiVersion);

        @Delete("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Head("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({204, 404})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> checkExistenceAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Get("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> getAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Resources/deployments/{deploymentName}/cancel")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> cancelAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Resources/deployments/{deploymentName}/validate")
        @ExpectedResponses({200, 400})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Get("/providers/Microsoft.Resources/deployments/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtTenantScope(@HostParam("$host") String host, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @QueryParam("api-version") String apiVersion);

        @Delete("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Head("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({204, 404})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> checkExistenceAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Get("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> getAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> cancelAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate")
        @ExpectedResponses({200, 400})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Get("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @QueryParam("api-version") String apiVersion);

        @Delete("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Head("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({204, 404})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> checkExistenceAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Put("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> getAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> cancelAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate")
        @ExpectedResponses({200, 400})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> whatIfAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentWhatIf parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Get("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> list(@HostParam("$host") String host, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Delete("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> delete(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Head("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({204, 404})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> checkExistence(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Put("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdate(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Get("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> getByResourceGroup(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel")
        @ExpectedResponses({204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> cancel(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate")
        @ExpectedResponses({200, 400})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentValidateResultInner>> validate(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<Flux<ByteBuffer>>> whatIf(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentWhatIf parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplate(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Get("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listByResourceGroup(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Post("/providers/Microsoft.Resources/calculateTemplateHash")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<TemplateHashResultInner>> calculateTemplateHash(@HostParam("$host") String host, @BodyParam("application/json") Object template, @QueryParam("api-version") String apiVersion);

        @Delete("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> beginDeleteAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtScope(@HostParam("$host") String host, @PathParam("scope") String scope, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Delete("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> beginDeleteAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtTenantScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Delete("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> beginDeleteAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @QueryParam("api-version") String apiVersion);

        @Put("/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtManagementGroupScope(@HostParam("$host") String host, @PathParam("groupId") String groupId, @PathParam("deploymentName") String deploymentName, @BodyParam("application/json") ScopedDeployment parameters, @QueryParam("api-version") String apiVersion);

        @Delete("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> beginDeleteAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Put("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<DeploymentsBeginWhatIfAtSubscriptionScopeResponse> beginWhatIfAtSubscriptionScope(@HostParam("$host") String host, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentWhatIf parameters, @QueryParam("api-version") String apiVersion);

        @Delete("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<Response<Void>> beginDelete(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion);

        @Put("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}")
        @ExpectedResponses({200, 201})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdate(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentInner parameters, @QueryParam("api-version") String apiVersion);

        @Post("/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf")
        @ExpectedResponses({200, 202})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<DeploymentsBeginWhatIfResponse> beginWhatIf(@HostParam("$host") String host, @PathParam("resourceGroupName") String resourceGroupName, @PathParam("deploymentName") String deploymentName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("application/json") DeploymentWhatIf parameters, @QueryParam("api-version") String apiVersion);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtScopeNext(@PathParam(value = "nextLink", encoded = true) String nextLink);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtTenantScopeNext(@PathParam(value = "nextLink", encoded = true) String nextLink);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtManagementGroupScopeNext(@PathParam(value = "nextLink", encoded = true) String nextLink);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listAtSubscriptionScopeNext(@PathParam(value = "nextLink", encoded = true) String nextLink);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(CloudException.class)
        Mono<SimpleResponse<DeploymentListResultInner>> listByResourceGroupNext(@PathParam(value = "nextLink", encoded = true) String nextLink);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.deleteAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAtScopeAsync(String scope, String deploymentName) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = deleteAtScopeWithResponseAsync(scope, deploymentName);
        return client.<Void, Void>getLroResultAsync(response, client.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAtScope(String scope, String deploymentName) {
        deleteAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * Checks whether the deployment exists.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> checkExistenceAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.checkExistenceAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Boolean> checkExistenceAtScopeAsync(String scope, String deploymentName) {
        return checkExistenceAtScopeWithResponseAsync(scope, deploymentName)
            .flatMap((Response<Void> res) -> Mono.just(res.getStatusCode() / 100 == 2));
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean checkExistenceAtScope(String scope, String deploymentName) {
        return checkExistenceAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtScopeWithResponseAsync(String scope, String deploymentName, DeploymentInner parameters) {
        return service.createOrUpdateAtScope(this.client.getHost(), scope, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> createOrUpdateAtScopeAsync(String scope, String deploymentName, DeploymentInner parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = createOrUpdateAtScopeWithResponseAsync(scope, deploymentName, parameters);
        return client.<DeploymentExtendedInner, DeploymentExtendedInner>getLroResultAsync(response, client.getHttpPipeline(), DeploymentExtendedInner.class, DeploymentExtendedInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner createOrUpdateAtScope(String scope, String deploymentName, DeploymentInner parameters) {
        return createOrUpdateAtScopeAsync(scope, deploymentName, parameters).block();
    }

    /**
     * Gets a deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> getAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.getAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    /**
     * Gets a deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> getAtScopeAsync(String scope, String deploymentName) {
        return getAtScopeWithResponseAsync(scope, deploymentName)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gets a deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner getAtScope(String scope, String deploymentName) {
        return getAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.cancelAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelAtScopeAsync(String scope, String deploymentName) {
        return cancelAtScopeWithResponseAsync(scope, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void cancelAtScope(String scope, String deploymentName) {
        cancelAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtScopeWithResponseAsync(String scope, String deploymentName, DeploymentInner parameters) {
        return service.validateAtScope(this.client.getHost(), scope, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentValidateResultInner> validateAtScopeAsync(String scope, String deploymentName, DeploymentInner parameters) {
        return validateAtScopeWithResponseAsync(scope, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentValidateResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentValidateResultInner validateAtScope(String scope, String deploymentName, DeploymentInner parameters) {
        return validateAtScopeAsync(scope, deploymentName, parameters).block();
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.exportTemplateAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExportResultInner> exportTemplateAtScopeAsync(String scope, String deploymentName) {
        return exportTemplateAtScopeWithResponseAsync(scope, deploymentName)
            .flatMap((SimpleResponse<DeploymentExportResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExportResultInner exportTemplateAtScope(String scope, String deploymentName) {
        return exportTemplateAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * Get all the deployments at the given scope.
     * 
     * @param scope The additional properties.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtScopeSinglePageAsync(String scope, String filter, Integer top) {
        return service.listAtScope(this.client.getHost(), scope, filter, top, this.client.getApiVersion()).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get all the deployments at the given scope.
     * 
     * @param scope The additional properties.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DeploymentExtendedInner> listAtScopeAsync(String scope, String filter, Integer top) {
        return new PagedFlux<>(
            () -> listAtScopeSinglePageAsync(scope, filter, top),
            nextLink -> listAtScopeNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the deployments at the given scope.
     * 
     * @param scope The additional properties.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeploymentExtendedInner> listAtScope(String scope, String filter, Integer top) {
        return new PagedIterable<>(listAtScopeAsync(scope, filter, top));
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.deleteAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAtTenantScopeAsync(String deploymentName) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = deleteAtTenantScopeWithResponseAsync(deploymentName);
        return client.<Void, Void>getLroResultAsync(response, client.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAtTenantScope(String deploymentName) {
        deleteAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * Checks whether the deployment exists.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> checkExistenceAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.checkExistenceAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Boolean> checkExistenceAtTenantScopeAsync(String deploymentName) {
        return checkExistenceAtTenantScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.just(res.getStatusCode() / 100 == 2));
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean checkExistenceAtTenantScope(String deploymentName) {
        return checkExistenceAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtTenantScopeWithResponseAsync(String deploymentName, ScopedDeployment parameters) {
        return service.createOrUpdateAtTenantScope(this.client.getHost(), deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> createOrUpdateAtTenantScopeAsync(String deploymentName, ScopedDeployment parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = createOrUpdateAtTenantScopeWithResponseAsync(deploymentName, parameters);
        return client.<DeploymentExtendedInner, DeploymentExtendedInner>getLroResultAsync(response, client.getHttpPipeline(), DeploymentExtendedInner.class, DeploymentExtendedInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner createOrUpdateAtTenantScope(String deploymentName, ScopedDeployment parameters) {
        return createOrUpdateAtTenantScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> getAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.getAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> getAtTenantScopeAsync(String deploymentName) {
        return getAtTenantScopeWithResponseAsync(deploymentName)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner getAtTenantScope(String deploymentName) {
        return getAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.cancelAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelAtTenantScopeAsync(String deploymentName) {
        return cancelAtTenantScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void cancelAtTenantScope(String deploymentName) {
        cancelAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtTenantScopeWithResponseAsync(String deploymentName, ScopedDeployment parameters) {
        return service.validateAtTenantScope(this.client.getHost(), deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentValidateResultInner> validateAtTenantScopeAsync(String deploymentName, ScopedDeployment parameters) {
        return validateAtTenantScopeWithResponseAsync(deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentValidateResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentValidateResultInner validateAtTenantScope(String deploymentName, ScopedDeployment parameters) {
        return validateAtTenantScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.exportTemplateAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExportResultInner> exportTemplateAtTenantScopeAsync(String deploymentName) {
        return exportTemplateAtTenantScopeWithResponseAsync(deploymentName)
            .flatMap((SimpleResponse<DeploymentExportResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExportResultInner exportTemplateAtTenantScope(String deploymentName) {
        return exportTemplateAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * Get all the deployments at the tenant scope.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtTenantScopeSinglePageAsync(String filter, Integer top) {
        return service.listAtTenantScope(this.client.getHost(), filter, top, this.client.getApiVersion()).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get all the deployments at the tenant scope.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DeploymentExtendedInner> listAtTenantScopeAsync(String filter, Integer top) {
        return new PagedFlux<>(
            () -> listAtTenantScopeSinglePageAsync(filter, top),
            nextLink -> listAtTenantScopeNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the deployments at the tenant scope.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeploymentExtendedInner> listAtTenantScope(String filter, Integer top) {
        return new PagedIterable<>(listAtTenantScopeAsync(filter, top));
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.deleteAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = deleteAtManagementGroupScopeWithResponseAsync(groupId, deploymentName);
        return client.<Void, Void>getLroResultAsync(response, client.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAtManagementGroupScope(String groupId, String deploymentName) {
        deleteAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * Checks whether the deployment exists.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> checkExistenceAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.checkExistenceAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Boolean> checkExistenceAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        return checkExistenceAtManagementGroupScopeWithResponseAsync(groupId, deploymentName)
            .flatMap((Response<Void> res) -> Mono.just(res.getStatusCode() / 100 == 2));
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean checkExistenceAtManagementGroupScope(String groupId, String deploymentName) {
        return checkExistenceAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        return service.createOrUpdateAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> createOrUpdateAtManagementGroupScopeAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = createOrUpdateAtManagementGroupScopeWithResponseAsync(groupId, deploymentName, parameters);
        return client.<DeploymentExtendedInner, DeploymentExtendedInner>getLroResultAsync(response, client.getHttpPipeline(), DeploymentExtendedInner.class, DeploymentExtendedInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner createOrUpdateAtManagementGroupScope(String groupId, String deploymentName, ScopedDeployment parameters) {
        return createOrUpdateAtManagementGroupScopeAsync(groupId, deploymentName, parameters).block();
    }

    /**
     * Gets a deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> getAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.getAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    /**
     * Gets a deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> getAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        return getAtManagementGroupScopeWithResponseAsync(groupId, deploymentName)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gets a deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner getAtManagementGroupScope(String groupId, String deploymentName) {
        return getAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.cancelAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        return cancelAtManagementGroupScopeWithResponseAsync(groupId, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void cancelAtManagementGroupScope(String groupId, String deploymentName) {
        cancelAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        return service.validateAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentValidateResultInner> validateAtManagementGroupScopeAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        return validateAtManagementGroupScopeWithResponseAsync(groupId, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentValidateResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentValidateResultInner validateAtManagementGroupScope(String groupId, String deploymentName, ScopedDeployment parameters) {
        return validateAtManagementGroupScopeAsync(groupId, deploymentName, parameters).block();
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.exportTemplateAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExportResultInner> exportTemplateAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        return exportTemplateAtManagementGroupScopeWithResponseAsync(groupId, deploymentName)
            .flatMap((SimpleResponse<DeploymentExportResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExportResultInner exportTemplateAtManagementGroupScope(String groupId, String deploymentName) {
        return exportTemplateAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * Get all the deployments for a management group.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtManagementGroupScopeSinglePageAsync(String groupId, String filter, Integer top) {
        return service.listAtManagementGroupScope(this.client.getHost(), groupId, filter, top, this.client.getApiVersion()).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get all the deployments for a management group.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DeploymentExtendedInner> listAtManagementGroupScopeAsync(String groupId, String filter, Integer top) {
        return new PagedFlux<>(
            () -> listAtManagementGroupScopeSinglePageAsync(groupId, filter, top),
            nextLink -> listAtManagementGroupScopeNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the deployments for a management group.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeploymentExtendedInner> listAtManagementGroupScope(String groupId, String filter, Integer top) {
        return new PagedIterable<>(listAtManagementGroupScopeAsync(groupId, filter, top));
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> deleteAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.deleteAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAtSubscriptionScopeAsync(String deploymentName) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = deleteAtSubscriptionScopeWithResponseAsync(deploymentName);
        return client.<Void, Void>getLroResultAsync(response, client.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteAtSubscriptionScope(String deploymentName) {
        deleteAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * Checks whether the deployment exists.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> checkExistenceAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.checkExistenceAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Boolean> checkExistenceAtSubscriptionScopeAsync(String deploymentName) {
        return checkExistenceAtSubscriptionScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.just(res.getStatusCode() / 100 == 2));
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean checkExistenceAtSubscriptionScope(String deploymentName) {
        return checkExistenceAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateAtSubscriptionScopeWithResponseAsync(String deploymentName, DeploymentInner parameters) {
        return service.createOrUpdateAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> createOrUpdateAtSubscriptionScopeAsync(String deploymentName, DeploymentInner parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = createOrUpdateAtSubscriptionScopeWithResponseAsync(deploymentName, parameters);
        return client.<DeploymentExtendedInner, DeploymentExtendedInner>getLroResultAsync(response, client.getHttpPipeline(), DeploymentExtendedInner.class, DeploymentExtendedInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner createOrUpdateAtSubscriptionScope(String deploymentName, DeploymentInner parameters) {
        return createOrUpdateAtSubscriptionScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> getAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.getAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> getAtSubscriptionScopeAsync(String deploymentName) {
        return getAtSubscriptionScopeWithResponseAsync(deploymentName)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gets a deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner getAtSubscriptionScope(String deploymentName) {
        return getAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.cancelAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelAtSubscriptionScopeAsync(String deploymentName) {
        return cancelAtSubscriptionScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void cancelAtSubscriptionScope(String deploymentName) {
        cancelAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentValidateResultInner>> validateAtSubscriptionScopeWithResponseAsync(String deploymentName, DeploymentInner parameters) {
        return service.validateAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentValidateResultInner> validateAtSubscriptionScopeAsync(String deploymentName, DeploymentInner parameters) {
        return validateAtSubscriptionScopeWithResponseAsync(deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentValidateResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentValidateResultInner validateAtSubscriptionScope(String deploymentName, DeploymentInner parameters) {
        return validateAtSubscriptionScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> whatIfAtSubscriptionScopeWithResponseAsync(String deploymentName, DeploymentWhatIf parameters) {
        return service.whatIfAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<WhatIfOperationResultInner> whatIfAtSubscriptionScopeAsync(String deploymentName, DeploymentWhatIf parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = whatIfAtSubscriptionScopeWithResponseAsync(deploymentName, parameters);
        return client.<WhatIfOperationResultInner, WhatIfOperationResultInner>getLroResultAsync(response, client.getHttpPipeline(), WhatIfOperationResultInner.class, WhatIfOperationResultInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WhatIfOperationResultInner whatIfAtSubscriptionScope(String deploymentName, DeploymentWhatIf parameters) {
        return whatIfAtSubscriptionScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.exportTemplateAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExportResultInner> exportTemplateAtSubscriptionScopeAsync(String deploymentName) {
        return exportTemplateAtSubscriptionScopeWithResponseAsync(deploymentName)
            .flatMap((SimpleResponse<DeploymentExportResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExportResultInner exportTemplateAtSubscriptionScope(String deploymentName) {
        return exportTemplateAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * Get all the deployments for a subscription.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listSinglePageAsync(String filter, Integer top) {
        return service.list(this.client.getHost(), filter, top, this.client.getSubscriptionId(), this.client.getApiVersion()).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get all the deployments for a subscription.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DeploymentExtendedInner> listAsync(String filter, Integer top) {
        return new PagedFlux<>(
            () -> listSinglePageAsync(filter, top),
            nextLink -> listAtSubscriptionScopeNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the deployments for a subscription.
     * 
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeploymentExtendedInner> list(String filter, Integer top) {
        return new PagedIterable<>(listAsync(filter, top));
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> deleteWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.delete(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(String resourceGroupName, String deploymentName) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = deleteWithResponseAsync(resourceGroupName, deploymentName);
        return client.<Void, Void>getLroResultAsync(response, client.getHttpPipeline(), Void.class, Void.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(String resourceGroupName, String deploymentName) {
        deleteAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * Checks whether the deployment exists.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> checkExistenceWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.checkExistence(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Boolean> checkExistenceAsync(String resourceGroupName, String deploymentName) {
        return checkExistenceWithResponseAsync(resourceGroupName, deploymentName)
            .flatMap((Response<Void> res) -> Mono.just(res.getStatusCode() / 100 == 2));
    }

    @ServiceMethod(returns = ReturnType.SINGLE)
    public boolean checkExistence(String resourceGroupName, String deploymentName) {
        return checkExistenceAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> createOrUpdateWithResponseAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return service.createOrUpdate(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> createOrUpdateAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = createOrUpdateWithResponseAsync(resourceGroupName, deploymentName, parameters);
        return client.<DeploymentExtendedInner, DeploymentExtendedInner>getLroResultAsync(response, client.getHttpPipeline(), DeploymentExtendedInner.class, DeploymentExtendedInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner createOrUpdate(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return createOrUpdateAsync(resourceGroupName, deploymentName, parameters).block();
    }

    /**
     * Gets a deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> getByResourceGroupWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.getByResourceGroup(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * Gets a deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> getByResourceGroupAsync(String resourceGroupName, String deploymentName) {
        return getByResourceGroupWithResponseAsync(resourceGroupName, deploymentName)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Gets a deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner getByResourceGroup(String resourceGroupName, String deploymentName) {
        return getByResourceGroupAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> cancelWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.cancel(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> cancelAsync(String resourceGroupName, String deploymentName) {
        return cancelWithResponseAsync(resourceGroupName, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void cancel(String resourceGroupName, String deploymentName) {
        cancelAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentValidateResultInner>> validateWithResponseAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return service.validate(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentValidateResultInner> validateAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return validateWithResponseAsync(resourceGroupName, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentValidateResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentValidateResultInner validate(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return validateAsync(resourceGroupName, deploymentName, parameters).block();
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Flux<ByteBuffer>>> whatIfWithResponseAsync(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        return service.whatIf(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<WhatIfOperationResultInner> whatIfAsync(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        Mono<SimpleResponse<Flux<ByteBuffer>>> response = whatIfWithResponseAsync(resourceGroupName, deploymentName, parameters);
        return client.<WhatIfOperationResultInner, WhatIfOperationResultInner>getLroResultAsync(response, client.getHttpPipeline(), WhatIfOperationResultInner.class, WhatIfOperationResultInner.class)
            .last()
            .flatMap(AsyncPollResponse::getFinalResult);
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WhatIfOperationResultInner whatIf(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        return whatIfAsync(resourceGroupName, deploymentName, parameters).block();
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExportResultInner>> exportTemplateWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.exportTemplate(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExportResultInner> exportTemplateAsync(String resourceGroupName, String deploymentName) {
        return exportTemplateWithResponseAsync(resourceGroupName, deploymentName)
            .flatMap((SimpleResponse<DeploymentExportResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Exports the template used for specified deployment.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExportResultInner exportTemplate(String resourceGroupName, String deploymentName) {
        return exportTemplateAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * Get all the deployments for a resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listByResourceGroupSinglePageAsync(String resourceGroupName, String filter, Integer top) {
        return service.listByResourceGroup(this.client.getHost(), resourceGroupName, filter, top, this.client.getSubscriptionId(), this.client.getApiVersion()).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get all the deployments for a resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<DeploymentExtendedInner> listByResourceGroupAsync(String resourceGroupName, String filter, Integer top) {
        return new PagedFlux<>(
            () -> listByResourceGroupSinglePageAsync(resourceGroupName, filter, top),
            nextLink -> listByResourceGroupNextSinglePageAsync(nextLink));
    }

    /**
     * Get all the deployments for a resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param filter The additional properties.
     * @param top MISSING·SCHEMA-DESCRIPTION-INTEGER.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DeploymentExtendedInner> listByResourceGroup(String resourceGroupName, String filter, Integer top) {
        return new PagedIterable<>(listByResourceGroupAsync(resourceGroupName, filter, top));
    }

    /**
     * Calculate the hash of the given template.
     * 
     * @param template MISSING·SCHEMA-DESCRIPTION-OBJECTSCHEMA.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<TemplateHashResultInner>> calculateTemplateHashWithResponseAsync(Object template) {
        return service.calculateTemplateHash(this.client.getHost(), template, this.client.getApiVersion());
    }

    /**
     * Calculate the hash of the given template.
     * 
     * @param template MISSING·SCHEMA-DESCRIPTION-OBJECTSCHEMA.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<TemplateHashResultInner> calculateTemplateHashAsync(Object template) {
        return calculateTemplateHashWithResponseAsync(template)
            .flatMap((SimpleResponse<TemplateHashResultInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Calculate the hash of the given template.
     * 
     * @param template MISSING·SCHEMA-DESCRIPTION-OBJECTSCHEMA.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public TemplateHashResultInner calculateTemplateHash(Object template) {
        return calculateTemplateHashAsync(template).block();
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteAtScopeWithResponseAsync(String scope, String deploymentName) {
        return service.beginDeleteAtScope(this.client.getHost(), scope, deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteAtScopeAsync(String scope, String deploymentName) {
        return beginDeleteAtScopeWithResponseAsync(scope, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteAtScope(String scope, String deploymentName) {
        beginDeleteAtScopeAsync(scope, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtScopeWithResponseAsync(String scope, String deploymentName, DeploymentInner parameters) {
        return service.beginCreateOrUpdateAtScope(this.client.getHost(), scope, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> beginCreateOrUpdateAtScopeAsync(String scope, String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateAtScopeWithResponseAsync(scope, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param scope The additional properties.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner beginCreateOrUpdateAtScope(String scope, String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateAtScopeAsync(scope, deploymentName, parameters).block();
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteAtTenantScopeWithResponseAsync(String deploymentName) {
        return service.beginDeleteAtTenantScope(this.client.getHost(), deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteAtTenantScopeAsync(String deploymentName) {
        return beginDeleteAtTenantScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteAtTenantScope(String deploymentName) {
        beginDeleteAtTenantScopeAsync(deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtTenantScopeWithResponseAsync(String deploymentName, ScopedDeployment parameters) {
        return service.beginCreateOrUpdateAtTenantScope(this.client.getHost(), deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> beginCreateOrUpdateAtTenantScopeAsync(String deploymentName, ScopedDeployment parameters) {
        return beginCreateOrUpdateAtTenantScopeWithResponseAsync(deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner beginCreateOrUpdateAtTenantScope(String deploymentName, ScopedDeployment parameters) {
        return beginCreateOrUpdateAtTenantScopeAsync(deploymentName, parameters).block();
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName) {
        return service.beginDeleteAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteAtManagementGroupScopeAsync(String groupId, String deploymentName) {
        return beginDeleteAtManagementGroupScopeWithResponseAsync(groupId, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteAtManagementGroupScope(String groupId, String deploymentName) {
        beginDeleteAtManagementGroupScopeAsync(groupId, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtManagementGroupScopeWithResponseAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        return service.beginCreateOrUpdateAtManagementGroupScope(this.client.getHost(), groupId, deploymentName, parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> beginCreateOrUpdateAtManagementGroupScopeAsync(String groupId, String deploymentName, ScopedDeployment parameters) {
        return beginCreateOrUpdateAtManagementGroupScopeWithResponseAsync(groupId, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param groupId MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner beginCreateOrUpdateAtManagementGroupScope(String groupId, String deploymentName, ScopedDeployment parameters) {
        return beginCreateOrUpdateAtManagementGroupScopeAsync(groupId, deploymentName, parameters).block();
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteAtSubscriptionScopeWithResponseAsync(String deploymentName) {
        return service.beginDeleteAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteAtSubscriptionScopeAsync(String deploymentName) {
        return beginDeleteAtSubscriptionScopeWithResponseAsync(deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDeleteAtSubscriptionScope(String deploymentName) {
        beginDeleteAtSubscriptionScopeAsync(deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateAtSubscriptionScopeWithResponseAsync(String deploymentName, DeploymentInner parameters) {
        return service.beginCreateOrUpdateAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> beginCreateOrUpdateAtSubscriptionScopeAsync(String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateAtSubscriptionScopeWithResponseAsync(deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner beginCreateOrUpdateAtSubscriptionScope(String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateAtSubscriptionScopeAsync(deploymentName, parameters).block();
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentsBeginWhatIfAtSubscriptionScopeResponse> beginWhatIfAtSubscriptionScopeWithResponseAsync(String deploymentName, DeploymentWhatIf parameters) {
        return service.beginWhatIfAtSubscriptionScope(this.client.getHost(), deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<WhatIfOperationResultInner> beginWhatIfAtSubscriptionScopeAsync(String deploymentName, DeploymentWhatIf parameters) {
        return beginWhatIfAtSubscriptionScopeWithResponseAsync(deploymentName, parameters)
            .flatMap((DeploymentsBeginWhatIfAtSubscriptionScopeResponse res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * 
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WhatIfOperationResultInner beginWhatIfAtSubscriptionScope(String deploymentName, DeploymentWhatIf parameters) {
        return beginWhatIfAtSubscriptionScopeAsync(deploymentName, parameters).block();
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> beginDeleteWithResponseAsync(String resourceGroupName, String deploymentName) {
        return service.beginDelete(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), this.client.getApiVersion());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> beginDeleteAsync(String resourceGroupName, String deploymentName) {
        return beginDeleteWithResponseAsync(resourceGroupName, deploymentName)
            .flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void beginDelete(String resourceGroupName, String deploymentName) {
        beginDeleteAsync(resourceGroupName, deploymentName).block();
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<DeploymentExtendedInner>> beginCreateOrUpdateWithResponseAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return service.beginCreateOrUpdate(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentExtendedInner> beginCreateOrUpdateAsync(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateWithResponseAsync(resourceGroupName, deploymentName, parameters)
            .flatMap((SimpleResponse<DeploymentExtendedInner> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DeploymentExtendedInner beginCreateOrUpdate(String resourceGroupName, String deploymentName, DeploymentInner parameters) {
        return beginCreateOrUpdateAsync(resourceGroupName, deploymentName, parameters).block();
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<DeploymentsBeginWhatIfResponse> beginWhatIfWithResponseAsync(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        return service.beginWhatIf(this.client.getHost(), resourceGroupName, deploymentName, this.client.getSubscriptionId(), parameters, this.client.getApiVersion());
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<WhatIfOperationResultInner> beginWhatIfAsync(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        return beginWhatIfWithResponseAsync(resourceGroupName, deploymentName, parameters)
            .flatMap((DeploymentsBeginWhatIfResponse res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * 
     * @param resourceGroupName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param deploymentName MISSING·SCHEMA-DESCRIPTION-STRING.
     * @param parameters Deployment What-if operation parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public WhatIfOperationResultInner beginWhatIf(String resourceGroupName, String deploymentName, DeploymentWhatIf parameters) {
        return beginWhatIfAsync(resourceGroupName, deploymentName, parameters).block();
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink null
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtScopeNextSinglePageAsync(String nextLink) {
        return service.listAtScopeNext(nextLink).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink null
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtTenantScopeNextSinglePageAsync(String nextLink) {
        return service.listAtTenantScopeNext(nextLink).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink null
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtManagementGroupScopeNextSinglePageAsync(String nextLink) {
        return service.listAtManagementGroupScopeNext(nextLink).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink null
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listAtSubscriptionScopeNextSinglePageAsync(String nextLink) {
        return service.listAtSubscriptionScopeNext(nextLink).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }

    /**
     * Get the next page of items.
     * 
     * @param nextLink null
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<DeploymentExtendedInner>> listByResourceGroupNextSinglePageAsync(String nextLink) {
        return service.listByResourceGroupNext(nextLink).map(res -> new PagedResponseBase<>(
            res.getRequest(),
            res.getStatusCode(),
            res.getHeaders(),
            res.getValue().getValue(),
            res.getValue().getNextLink(),
            null));
    }
}
