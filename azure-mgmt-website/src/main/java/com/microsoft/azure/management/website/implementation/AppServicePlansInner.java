/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.website.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in AppServicePlans.
 */
public final class AppServicePlansInner {
    /** The Retrofit service to perform REST calls. */
    private AppServicePlansService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of AppServicePlansInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public AppServicePlansInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(AppServicePlansService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for AppServicePlans to be
     * used by Retrofit to perform actually REST calls.
     */
    interface AppServicePlansService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/serverfarms")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("detailed") Boolean detailed, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body AppServicePlanInner appServicePlan, @Query("allowPendingState") Boolean allowPendingState, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body AppServicePlanInner appServicePlan, @Query("allowPendingState") Boolean allowPendingState, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/capabilities")
        Observable<Response<ResponseBody>> listCapabilities(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connection, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeys(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/sites")
        Observable<Response<ResponseBody>> listHybridConnectionWebApps(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionPlanLimits/limit")
        Observable<Response<ResponseBody>> getHybridConnectionPlanLimit(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefintions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/metrics")
        Observable<Response<ResponseBody>> listMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/restartSites")
        Observable<Response<ResponseBody>> restartWebApps(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/sites")
        Observable<Response<ResponseBody>> listWebApps(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("$skipToken") String skipToken, @Query("$filter") String filter, @Query("$top") String top, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetFromServerFarm(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes")
        Observable<Response<ResponseBody>> listtRoutesForVnet(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}")
        Observable<Response<ResponseBody>> getRouteForVnet(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("routeName") String routeName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetRoute(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("routeName") String routeName, @Path("subscriptionId") String subscriptionId, @Body VnetRouteInner route, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetRoute(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("routeName") String routeName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}")
        Observable<Response<ResponseBody>> updateVnetRoute(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("routeName") String routeName, @Path("subscriptionId") String subscriptionId, @Body VnetRouteInner route, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/workers/{workerName}/reboot")
        Observable<Response<ResponseBody>> rebootWorker(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("workerName") String workerName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricDefintionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listWebAppsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @return the PagedList&lt;AppServicePlanInner&gt; object if successful.
     */
    public PagedList<AppServicePlanInner> list() {
        ServiceResponse<Page<AppServicePlanInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<AppServicePlanInner>(response.getBody()) {
            @Override
            public Page<AppServicePlanInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<AppServicePlanInner>> listAsync(final ListOperationCallback<AppServicePlanInner> serviceCallback) {
        return AzureServiceCall.create(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<Page<AppServicePlanInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Page<AppServicePlanInner>>() {
                @Override
                public Page<AppServicePlanInner> call(ServiceResponse<Page<AppServicePlanInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(ServiceResponse<Page<AppServicePlanInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @return the PagedList&lt;AppServicePlanInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        final Boolean detailed = null;
        return service.list(this.client.subscriptionId(), detailed, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AppServicePlanInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AppServicePlanInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param detailed False to return a subset of App Service Plan properties, true to return all of the properties.
                 Retrieval of all properties may increase the API latency.
     * @return the PagedList&lt;AppServicePlanInner&gt; object if successful.
     */
    public PagedList<AppServicePlanInner> list(final Boolean detailed) {
        ServiceResponse<Page<AppServicePlanInner>> response = listSinglePageAsync(detailed).toBlocking().single();
        return new PagedList<AppServicePlanInner>(response.getBody()) {
            @Override
            public Page<AppServicePlanInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param detailed False to return a subset of App Service Plan properties, true to return all of the properties.
                 Retrieval of all properties may increase the API latency.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<AppServicePlanInner>> listAsync(final Boolean detailed, final ListOperationCallback<AppServicePlanInner> serviceCallback) {
        return AzureServiceCall.create(
            listSinglePageAsync(detailed),
            new Func1<String, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param detailed False to return a subset of App Service Plan properties, true to return all of the properties.
                 Retrieval of all properties may increase the API latency.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<Page<AppServicePlanInner>> listAsync(final Boolean detailed) {
        return listWithServiceResponseAsync(detailed)
            .map(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Page<AppServicePlanInner>>() {
                @Override
                public Page<AppServicePlanInner> call(ServiceResponse<Page<AppServicePlanInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param detailed False to return a subset of App Service Plan properties, true to return all of the properties.
                 Retrieval of all properties may increase the API latency.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listWithServiceResponseAsync(final Boolean detailed) {
        return listSinglePageAsync(detailed)
            .concatMap(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(ServiceResponse<Page<AppServicePlanInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
    ServiceResponse<PageImpl<AppServicePlanInner>> * @param detailed False to return a subset of App Service Plan properties, true to return all of the properties.
                 Retrieval of all properties may increase the API latency.
     * @return the PagedList&lt;AppServicePlanInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listSinglePageAsync(final Boolean detailed) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.list(this.client.subscriptionId(), detailed, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AppServicePlanInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AppServicePlanInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AppServicePlanInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<AppServicePlanInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<AppServicePlanInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;AppServicePlanInner&gt; object if successful.
     */
    public PagedList<AppServicePlanInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<AppServicePlanInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<AppServicePlanInner>(response.getBody()) {
            @Override
            public Page<AppServicePlanInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<AppServicePlanInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<AppServicePlanInner> serviceCallback) {
        return AzureServiceCall.create(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<Page<AppServicePlanInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Page<AppServicePlanInner>>() {
                @Override
                public Page<AppServicePlanInner> call(ServiceResponse<Page<AppServicePlanInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(ServiceResponse<Page<AppServicePlanInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
    ServiceResponse<PageImpl<AppServicePlanInner>> * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;AppServicePlanInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AppServicePlanInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AppServicePlanInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AppServicePlanInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<AppServicePlanInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<AppServicePlanInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets specified App Service Plan in a resource group.
     * Gets specified App Service Plan in a resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the AppServicePlanInner object if successful.
     */
    public AppServicePlanInner get(String resourceGroupName, String name) {
        return getWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets specified App Service Plan in a resource group.
     * Gets specified App Service Plan in a resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> getAsync(String resourceGroupName, String name, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(getWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets specified App Service Plan in a resource group.
     * Gets specified App Service Plan in a resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<AppServicePlanInner> getAsync(String resourceGroupName, String name) {
        return getWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets specified App Service Plan in a resource group.
     * Gets specified App Service Plan in a resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<ServiceResponse<AppServicePlanInner>> getWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.get(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AppServicePlanInner>>>() {
                @Override
                public Observable<ServiceResponse<AppServicePlanInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AppServicePlanInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AppServicePlanInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<AppServicePlanInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<AppServicePlanInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the AppServicePlanInner object  if successful.
     */
    public AppServicePlanInner createOrUpdate(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan).toBlocking().last().getBody();
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> createOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan), serviceCallback);
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the observable for the request
     */
    public Observable<AppServicePlanInner> createOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the observable for the request
     */
    public Observable<ServiceResponse<AppServicePlanInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appServicePlan == null) {
            throw new IllegalArgumentException("Parameter appServicePlan is required and cannot be null.");
        }
        Validator.validate(appServicePlan);
        final String apiVersion = "2016-09-01";
        final Boolean allowPendingState = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), appServicePlan, allowPendingState, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<AppServicePlanInner>() { }.getType());
    }
    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the AppServicePlanInner object if successful.
     */
    public AppServicePlanInner createOrUpdate(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState).toBlocking().last().getBody();
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> createOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState), serviceCallback);
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the observable for the request
     */
    public Observable<AppServicePlanInner> createOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the observable for the request
     */
    public Observable<ServiceResponse<AppServicePlanInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appServicePlan == null) {
            throw new IllegalArgumentException("Parameter appServicePlan is required and cannot be null.");
        }
        Validator.validate(appServicePlan);
        final String apiVersion = "2016-09-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), appServicePlan, allowPendingState, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<AppServicePlanInner>() { }.getType());
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the AppServicePlanInner object if successful.
     */
    public AppServicePlanInner beginCreateOrUpdate(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan).toBlocking().single().getBody();
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan), serviceCallback);
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<AppServicePlanInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<ServiceResponse<AppServicePlanInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appServicePlan == null) {
            throw new IllegalArgumentException("Parameter appServicePlan is required and cannot be null.");
        }
        Validator.validate(appServicePlan);
        final String apiVersion = "2016-09-01";
        final Boolean allowPendingState = null;
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), appServicePlan, allowPendingState, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AppServicePlanInner>>>() {
                @Override
                public Observable<ServiceResponse<AppServicePlanInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AppServicePlanInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the AppServicePlanInner object if successful.
     */
    public AppServicePlanInner beginCreateOrUpdate(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState).toBlocking().single().getBody();
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState), serviceCallback);
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<AppServicePlanInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, appServicePlan, allowPendingState).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates or updates an App Service Plan.
     * Creates or updates an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param appServicePlan Details of App Service Plan
     * @param allowPendingState OBSOLETE: If true, allow pending state for App Service Plan
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<ServiceResponse<AppServicePlanInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, AppServicePlanInner appServicePlan, Boolean allowPendingState) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appServicePlan == null) {
            throw new IllegalArgumentException("Parameter appServicePlan is required and cannot be null.");
        }
        Validator.validate(appServicePlan);
        final String apiVersion = "2016-09-01";
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), appServicePlan, allowPendingState, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AppServicePlanInner>>>() {
                @Override
                public Observable<ServiceResponse<AppServicePlanInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AppServicePlanInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AppServicePlanInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<AppServicePlanInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<AppServicePlanInner>() { }.getType())
                .register(202, new TypeToken<AppServicePlanInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a App Service Plan.
     * Deletes a App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the Object object if successful.
     */
    public Object delete(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Deletes a App Service Plan.
     * Deletes a App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a App Service Plan.
     * Deletes a App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAsync(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a App Service Plan.
     * Deletes a App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List serverfarm capabilities.
     * List serverfarm capabilities.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the List&lt;CapabilityInner&gt; object if successful.
     */
    public List<CapabilityInner> listCapabilities(String resourceGroupName, String name) {
        return listCapabilitiesWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * List serverfarm capabilities.
     * List serverfarm capabilities.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CapabilityInner>> listCapabilitiesAsync(String resourceGroupName, String name, final ServiceCallback<List<CapabilityInner>> serviceCallback) {
        return ServiceCall.create(listCapabilitiesWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * List serverfarm capabilities.
     * List serverfarm capabilities.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the observable to the List&lt;CapabilityInner&gt; object
     */
    public Observable<List<CapabilityInner>> listCapabilitiesAsync(String resourceGroupName, String name) {
        return listCapabilitiesWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<CapabilityInner>>, List<CapabilityInner>>() {
            @Override
            public List<CapabilityInner> call(ServiceResponse<List<CapabilityInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * List serverfarm capabilities.
     * List serverfarm capabilities.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the observable to the List&lt;CapabilityInner&gt; object
     */
    public Observable<ServiceResponse<List<CapabilityInner>>> listCapabilitiesWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listCapabilities(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CapabilityInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<CapabilityInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CapabilityInner>> clientResponse = listCapabilitiesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CapabilityInner>> listCapabilitiesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<CapabilityInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<CapabilityInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     * Retrieves a specific Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param connection The hybrid connection entity
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connection) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connection).toBlocking().single().getBody();
    }

    /**
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param connection The hybrid connection entity
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connection, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connection), serviceCallback);
    }

    /**
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param connection The hybrid connection entity
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connection) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connection).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     * Updates an existing Service Bus Hybrid Connection in use on this App Service Plan. This will fail if the Hybrid Connection does not already exist.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param connection The hybrid connection entity
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connection) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connection == null) {
            throw new IllegalArgumentException("Parameter connection is required and cannot be null.");
        }
        Validator.validate(connection);
        final String apiVersion = "2016-09-01";
        return service.updateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connection, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the Object object if successful.
     */
    public Object deleteHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the Object object
     */
    public Observable<Object> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     * Deletes an existing Service Bus Hybrid Connection in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for this Hybrid Connection.
     * Gets the send key name and value for this Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the HybridConnectionKeyInner object if successful.
     */
    public HybridConnectionKeyInner listHybridConnectionKeys(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Gets the send key name and value for this Hybrid Connection.
     * Gets the send key name and value for this Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionKeyInner> serviceCallback) {
        return ServiceCall.create(listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Gets the send key name and value for this Hybrid Connection.
     * Gets the send key name and value for this Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<HybridConnectionKeyInner> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionKeyInner>, HybridConnectionKeyInner>() {
            @Override
            public HybridConnectionKeyInner call(ServiceResponse<HybridConnectionKeyInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the send key name and value for this Hybrid Connection.
     * Gets the send key name and value for this Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param namespaceName The name of the Service Bus Namespace
     * @param relayName The name of the Service Bus Relay
     * @return the observable to the HybridConnectionKeyInner object
     */
    public Observable<ServiceResponse<HybridConnectionKeyInner>> listHybridConnectionKeysWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionKeyInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionKeyInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionKeyInner> clientResponse = listHybridConnectionKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionKeyInner> listHybridConnectionKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionKeyInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionKeyInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param namespaceName The Hybrid Connection namespace
     * @param relayName The Hybrid Connection relay name
     * @return the Object object if successful.
     */
    public Object listHybridConnectionWebApps(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionWebAppsWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param namespaceName The Hybrid Connection namespace
     * @param relayName The Hybrid Connection relay name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listHybridConnectionWebAppsAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listHybridConnectionWebAppsWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param namespaceName The Hybrid Connection namespace
     * @param relayName The Hybrid Connection relay name
     * @return the observable to the Object object
     */
    public Observable<Object> listHybridConnectionWebAppsAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionWebAppsWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     * Gets a list of sites that are using a particular Hybrid Connection on an App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param namespaceName The Hybrid Connection namespace
     * @param relayName The Hybrid Connection relay name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listHybridConnectionWebAppsWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listHybridConnectionWebApps(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listHybridConnectionWebAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listHybridConnectionWebAppsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @return the Object object if successful.
     */
    public Object getHybridConnectionPlanLimit(String resourceGroupName, String name) {
        return getHybridConnectionPlanLimitWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getHybridConnectionPlanLimitAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getHybridConnectionPlanLimitWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @return the observable to the Object object
     */
    public Observable<Object> getHybridConnectionPlanLimitAsync(String resourceGroupName, String name) {
        return getHybridConnectionPlanLimitWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     * Gets the maximum number of Hybrid Connections allowed on a specified App Service Plan.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getHybridConnectionPlanLimitWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getHybridConnectionPlanLimit(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getHybridConnectionPlanLimitDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getHybridConnectionPlanLimitDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnections(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     * Retrieves all Service Bus Hybrid Connections in use on this App Service Plan.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the App Service Plan
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listHybridConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefintions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefintionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefintionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefintionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefintionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefintionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefintionsAsync(final String resourceGroupName, final String name) {
        return listMetricDefintionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefintionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricDefintionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefintionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of App Service Plan
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefintionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listMetricDefintions(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefintionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefintionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        final Boolean details = null;
        final String filter = null;
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param details If true, metrics are broken down per App Service Plan instance
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param details If true, metrics are broken down per App Service Plan instance
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param details If true, metrics are broken down per App Service Plan instance
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param details If true, metrics are broken down per App Service Plan instance
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of App Service Plan
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metrics are broken down per App Service Plan instance
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a server farm operation.
     * Gets a server farm operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param operationId Id of Server farm operation"&amp;gt;
     * @return the AppServicePlanInner object if successful.
     */
    public AppServicePlanInner getOperation(String resourceGroupName, String name, String operationId) {
        return getOperationWithServiceResponseAsync(resourceGroupName, name, operationId).toBlocking().single().getBody();
    }

    /**
     * Gets a server farm operation.
     * Gets a server farm operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param operationId Id of Server farm operation"&amp;gt;
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<AppServicePlanInner> getOperationAsync(String resourceGroupName, String name, String operationId, final ServiceCallback<AppServicePlanInner> serviceCallback) {
        return ServiceCall.create(getOperationWithServiceResponseAsync(resourceGroupName, name, operationId), serviceCallback);
    }

    /**
     * Gets a server farm operation.
     * Gets a server farm operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param operationId Id of Server farm operation"&amp;gt;
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<AppServicePlanInner> getOperationAsync(String resourceGroupName, String name, String operationId) {
        return getOperationWithServiceResponseAsync(resourceGroupName, name, operationId).map(new Func1<ServiceResponse<AppServicePlanInner>, AppServicePlanInner>() {
            @Override
            public AppServicePlanInner call(ServiceResponse<AppServicePlanInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a server farm operation.
     * Gets a server farm operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param operationId Id of Server farm operation"&amp;gt;
     * @return the observable to the AppServicePlanInner object
     */
    public Observable<ServiceResponse<AppServicePlanInner>> getOperationWithServiceResponseAsync(String resourceGroupName, String name, String operationId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getOperation(resourceGroupName, name, operationId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<AppServicePlanInner>>>() {
                @Override
                public Observable<ServiceResponse<AppServicePlanInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<AppServicePlanInner> clientResponse = getOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<AppServicePlanInner> getOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<AppServicePlanInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<AppServicePlanInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the Object object if successful.
     */
    public Object restartWebApps(String resourceGroupName, String name) {
        return restartWebAppsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartWebAppsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartWebAppsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the Object object
     */
    public Observable<Object> restartWebAppsAsync(String resourceGroupName, String name) {
        return restartWebAppsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartWebAppsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        final Boolean softRestart = null;
        return service.restartWebApps(resourceGroupName, name, this.client.subscriptionId(), softRestart, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartWebAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param softRestart Soft restart applies the configuration settings and restarts the apps if necessary. Hard restart always restarts and reprovisions the apps
     * @return the Object object if successful.
     */
    public Object restartWebApps(String resourceGroupName, String name, Boolean softRestart) {
        return restartWebAppsWithServiceResponseAsync(resourceGroupName, name, softRestart).toBlocking().single().getBody();
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param softRestart Soft restart applies the configuration settings and restarts the apps if necessary. Hard restart always restarts and reprovisions the apps
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartWebAppsAsync(String resourceGroupName, String name, Boolean softRestart, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartWebAppsWithServiceResponseAsync(resourceGroupName, name, softRestart), serviceCallback);
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param softRestart Soft restart applies the configuration settings and restarts the apps if necessary. Hard restart always restarts and reprovisions the apps
     * @return the observable to the Object object
     */
    public Observable<Object> restartWebAppsAsync(String resourceGroupName, String name, Boolean softRestart) {
        return restartWebAppsWithServiceResponseAsync(resourceGroupName, name, softRestart).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web apps in a specified App Service Plan.
     * Restarts web apps in a specified App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param softRestart Soft restart applies the configuration settings and restarts the apps if necessary. Hard restart always restarts and reprovisions the apps
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartWebAppsWithServiceResponseAsync(String resourceGroupName, String name, Boolean softRestart) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.restartWebApps(resourceGroupName, name, this.client.subscriptionId(), softRestart, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartWebAppsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartWebAppsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listWebApps(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInner>> response = listWebAppsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listWebAppsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listWebAppsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listWebAppsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listWebAppsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listWebAppsAsync(final String resourceGroupName, final String name) {
        return listWebAppsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listWebAppsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebAppsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        final String skipToken = null;
        final String filter = null;
        final String top = null;
        return service.listWebApps(resourceGroupName, name, this.client.subscriptionId(), skipToken, filter, top, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listWebAppsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param skipToken Skip to of web apps in a list. If specified, the resulting list will contain web apps starting from (including) the skipToken. Else, the resulting list contains web apps from the start of the list
     * @param filter Supported filter: $filter=state eq running. Returns only web apps that are currently running
     * @param top List page size. If specified, results are paged.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listWebApps(final String resourceGroupName, final String name, final String skipToken, final String filter, final String top) {
        ServiceResponse<Page<SiteInner>> response = listWebAppsSinglePageAsync(resourceGroupName, name, skipToken, filter, top).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listWebAppsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param skipToken Skip to of web apps in a list. If specified, the resulting list will contain web apps starting from (including) the skipToken. Else, the resulting list contains web apps from the start of the list
     * @param filter Supported filter: $filter=state eq running. Returns only web apps that are currently running
     * @param top List page size. If specified, results are paged.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listWebAppsAsync(final String resourceGroupName, final String name, final String skipToken, final String filter, final String top, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listWebAppsSinglePageAsync(resourceGroupName, name, skipToken, filter, top),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listWebAppsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param skipToken Skip to of web apps in a list. If specified, the resulting list will contain web apps starting from (including) the skipToken. Else, the resulting list contains web apps from the start of the list
     * @param filter Supported filter: $filter=state eq running. Returns only web apps that are currently running
     * @param top List page size. If specified, results are paged.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listWebAppsAsync(final String resourceGroupName, final String name, final String skipToken, final String filter, final String top) {
        return listWebAppsWithServiceResponseAsync(resourceGroupName, name, skipToken, filter, top)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param skipToken Skip to of web apps in a list. If specified, the resulting list will contain web apps starting from (including) the skipToken. Else, the resulting list contains web apps from the start of the list
     * @param filter Supported filter: $filter=state eq running. Returns only web apps that are currently running
     * @param top List page size. If specified, results are paged.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsWithServiceResponseAsync(final String resourceGroupName, final String name, final String skipToken, final String filter, final String top) {
        return listWebAppsSinglePageAsync(resourceGroupName, name, skipToken, filter, top)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebAppsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of App Service Plan
    ServiceResponse<PageImpl<SiteInner>> * @param skipToken Skip to of web apps in a list. If specified, the resulting list will contain web apps starting from (including) the skipToken. Else, the resulting list contains web apps from the start of the list
    ServiceResponse<PageImpl<SiteInner>> * @param filter Supported filter: $filter=state eq running. Returns only web apps that are currently running
    ServiceResponse<PageImpl<SiteInner>> * @param top List page size. If specified, results are paged.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsSinglePageAsync(final String resourceGroupName, final String name, final String skipToken, final String filter, final String top) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listWebApps(resourceGroupName, name, this.client.subscriptionId(), skipToken, filter, top, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listWebAppsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listWebAppsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets list of vnets associated with App Service Plan.
     * Gets list of vnets associated with App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnets(String resourceGroupName, String name) {
        return listVnetsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets list of vnets associated with App Service Plan.
     * Gets list of vnets associated with App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> listVnetsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(listVnetsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets list of vnets associated with App Service Plan.
     * Gets list of vnets associated with App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetsAsync(String resourceGroupName, String name) {
        return listVnetsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets list of vnets associated with App Service Plan.
     * Gets list of vnets associated with App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listVnets(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a vnet associated with an App Service Plan.
     * Gets a vnet associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetFromServerFarm(String resourceGroupName, String name, String vnetName) {
        return getVnetFromServerFarmWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Gets a vnet associated with an App Service Plan.
     * Gets a vnet associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getVnetFromServerFarmAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getVnetFromServerFarmWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Gets a vnet associated with an App Service Plan.
     * Gets a vnet associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetFromServerFarmAsync(String resourceGroupName, String name, String vnetName) {
        return getVnetFromServerFarmWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a vnet associated with an App Service Plan.
     * Gets a vnet associated with an App Service Plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetFromServerFarmWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getVnetFromServerFarm(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetFromServerFarmDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetFromServerFarmDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the vnet gateway.
     * Gets the vnet gateway.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of the App Service Plan
     * @param vnetName Name of the virtual network
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner getVnetGateway(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single().getBody();
    }

    /**
     * Gets the vnet gateway.
     * Gets the vnet gateway.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of the App Service Plan
     * @param vnetName Name of the virtual network
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> getVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(getVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Gets the vnet gateway.
     * Gets the vnet gateway.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of the App Service Plan
     * @param vnetName Name of the virtual network
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> getVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the vnet gateway.
     * Gets the vnet gateway.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of the App Service Plan
     * @param vnetName Name of the virtual network
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> getVnetGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getVnetGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = getVnetGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> getVnetGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the vnet gateway.
     * Updates the vnet gateway.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param vnetName The name of the virtual network
     * @param gatewayName The name of the gateway. Only 'primary' is supported.
     * @param connectionEnvelope The gateway entity.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the vnet gateway.
     * Updates the vnet gateway.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param vnetName The name of the virtual network
     * @param gatewayName The name of the gateway. Only 'primary' is supported.
     * @param connectionEnvelope The gateway entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the vnet gateway.
     * Updates the vnet gateway.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param vnetName The name of the virtual network
     * @param gatewayName The name of the gateway. Only 'primary' is supported.
     * @param connectionEnvelope The gateway entity.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the vnet gateway.
     * Updates the vnet gateway.
     *
     * @param resourceGroupName The resource group
     * @param name The name of the App Service Plan
     * @param vnetName The name of the virtual network
     * @param gatewayName The name of the gateway. Only 'primary' is supported.
     * @param connectionEnvelope The gateway entity.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-09-01";
        return service.updateVnetGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a list of all routes associated with a vnet, in an app service plan.
     * Gets a list of all routes associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the List&lt;VnetRouteInner&gt; object if successful.
     */
    public List<VnetRouteInner> listtRoutesForVnet(String resourceGroupName, String name, String vnetName) {
        return listtRoutesForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Gets a list of all routes associated with a vnet, in an app service plan.
     * Gets a list of all routes associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetRouteInner>> listtRoutesForVnetAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<List<VnetRouteInner>> serviceCallback) {
        return ServiceCall.create(listtRoutesForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Gets a list of all routes associated with a vnet, in an app service plan.
     * Gets a list of all routes associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the observable to the List&lt;VnetRouteInner&gt; object
     */
    public Observable<List<VnetRouteInner>> listtRoutesForVnetAsync(String resourceGroupName, String name, String vnetName) {
        return listtRoutesForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<List<VnetRouteInner>>, List<VnetRouteInner>>() {
            @Override
            public List<VnetRouteInner> call(ServiceResponse<List<VnetRouteInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a list of all routes associated with a vnet, in an app service plan.
     * Gets a list of all routes associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @return the observable to the List&lt;VnetRouteInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetRouteInner>>> listtRoutesForVnetWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.listtRoutesForVnet(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetRouteInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetRouteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetRouteInner>> clientResponse = listtRoutesForVnetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetRouteInner>> listtRoutesForVnetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetRouteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetRouteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific route associated with a vnet, in an app service plan.
     * Gets a specific route associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the List&lt;VnetRouteInner&gt; object if successful.
     */
    public List<VnetRouteInner> getRouteForVnet(String resourceGroupName, String name, String vnetName, String routeName) {
        return getRouteForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName).toBlocking().single().getBody();
    }

    /**
     * Gets a specific route associated with a vnet, in an app service plan.
     * Gets a specific route associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetRouteInner>> getRouteForVnetAsync(String resourceGroupName, String name, String vnetName, String routeName, final ServiceCallback<List<VnetRouteInner>> serviceCallback) {
        return ServiceCall.create(getRouteForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName), serviceCallback);
    }

    /**
     * Gets a specific route associated with a vnet, in an app service plan.
     * Gets a specific route associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the observable to the List&lt;VnetRouteInner&gt; object
     */
    public Observable<List<VnetRouteInner>> getRouteForVnetAsync(String resourceGroupName, String name, String vnetName, String routeName) {
        return getRouteForVnetWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName).map(new Func1<ServiceResponse<List<VnetRouteInner>>, List<VnetRouteInner>>() {
            @Override
            public List<VnetRouteInner> call(ServiceResponse<List<VnetRouteInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a specific route associated with a vnet, in an app service plan.
     * Gets a specific route associated with a vnet, in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the observable to the List&lt;VnetRouteInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetRouteInner>>> getRouteForVnetWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String routeName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (routeName == null) {
            throw new IllegalArgumentException("Parameter routeName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.getRouteForVnet(resourceGroupName, name, vnetName, routeName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetRouteInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetRouteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetRouteInner>> clientResponse = getRouteForVnetDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetRouteInner>> getRouteForVnetDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetRouteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetRouteInner>>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the VnetRouteInner object if successful.
     */
    public VnetRouteInner createOrUpdateVnetRoute(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        return createOrUpdateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route).toBlocking().single().getBody();
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetRouteInner> createOrUpdateVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route, final ServiceCallback<VnetRouteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route), serviceCallback);
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the observable to the VnetRouteInner object
     */
    public Observable<VnetRouteInner> createOrUpdateVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        return createOrUpdateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route).map(new Func1<ServiceResponse<VnetRouteInner>, VnetRouteInner>() {
            @Override
            public VnetRouteInner call(ServiceResponse<VnetRouteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the observable to the VnetRouteInner object
     */
    public Observable<ServiceResponse<VnetRouteInner>> createOrUpdateVnetRouteWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (routeName == null) {
            throw new IllegalArgumentException("Parameter routeName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (route == null) {
            throw new IllegalArgumentException("Parameter route is required and cannot be null.");
        }
        Validator.validate(route);
        final String apiVersion = "2016-09-01";
        return service.createOrUpdateVnetRoute(resourceGroupName, name, vnetName, routeName, this.client.subscriptionId(), route, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetRouteInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetRouteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetRouteInner> clientResponse = createOrUpdateVnetRouteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetRouteInner> createOrUpdateVnetRouteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetRouteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetRouteInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes an existing route for a vnet in an app service plan.
     * Deletes an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the Object object if successful.
     */
    public Object deleteVnetRoute(String resourceGroupName, String name, String vnetName, String routeName) {
        return deleteVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName).toBlocking().single().getBody();
    }

    /**
     * Deletes an existing route for a vnet in an app service plan.
     * Deletes an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName), serviceCallback);
    }

    /**
     * Deletes an existing route for a vnet in an app service plan.
     * Deletes an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the observable to the Object object
     */
    public Observable<Object> deleteVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName) {
        return deleteVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes an existing route for a vnet in an app service plan.
     * Deletes an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteVnetRouteWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String routeName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (routeName == null) {
            throw new IllegalArgumentException("Parameter routeName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.deleteVnetRoute(resourceGroupName, name, vnetName, routeName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteVnetRouteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteVnetRouteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the VnetRouteInner object if successful.
     */
    public VnetRouteInner updateVnetRoute(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        return updateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route).toBlocking().single().getBody();
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetRouteInner> updateVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route, final ServiceCallback<VnetRouteInner> serviceCallback) {
        return ServiceCall.create(updateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route), serviceCallback);
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the observable to the VnetRouteInner object
     */
    public Observable<VnetRouteInner> updateVnetRouteAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        return updateVnetRouteWithServiceResponseAsync(resourceGroupName, name, vnetName, routeName, route).map(new Func1<ServiceResponse<VnetRouteInner>, VnetRouteInner>() {
            @Override
            public VnetRouteInner call(ServiceResponse<VnetRouteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     * Creates a new route or updates an existing route for a vnet in an app service plan.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of App Service Plan
     * @param vnetName Name of virtual network
     * @param routeName Name of the virtual network route
     * @param route The route object
     * @return the observable to the VnetRouteInner object
     */
    public Observable<ServiceResponse<VnetRouteInner>> updateVnetRouteWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String routeName, VnetRouteInner route) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (routeName == null) {
            throw new IllegalArgumentException("Parameter routeName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (route == null) {
            throw new IllegalArgumentException("Parameter route is required and cannot be null.");
        }
        Validator.validate(route);
        final String apiVersion = "2016-09-01";
        return service.updateVnetRoute(resourceGroupName, name, vnetName, routeName, this.client.subscriptionId(), route, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetRouteInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetRouteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetRouteInner> clientResponse = updateVnetRouteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetRouteInner> updateVnetRouteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetRouteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetRouteInner>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Submit a reboot request for a worker machine in the specified server farm.
     * Submit a reboot request for a worker machine in the specified server farm.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param workerName Name of worker machine, typically starts with RD
     * @return the Object object if successful.
     */
    public Object rebootWorker(String resourceGroupName, String name, String workerName) {
        return rebootWorkerWithServiceResponseAsync(resourceGroupName, name, workerName).toBlocking().single().getBody();
    }

    /**
     * Submit a reboot request for a worker machine in the specified server farm.
     * Submit a reboot request for a worker machine in the specified server farm.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param workerName Name of worker machine, typically starts with RD
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> rebootWorkerAsync(String resourceGroupName, String name, String workerName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(rebootWorkerWithServiceResponseAsync(resourceGroupName, name, workerName), serviceCallback);
    }

    /**
     * Submit a reboot request for a worker machine in the specified server farm.
     * Submit a reboot request for a worker machine in the specified server farm.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param workerName Name of worker machine, typically starts with RD
     * @return the observable to the Object object
     */
    public Observable<Object> rebootWorkerAsync(String resourceGroupName, String name, String workerName) {
        return rebootWorkerWithServiceResponseAsync(resourceGroupName, name, workerName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Submit a reboot request for a worker machine in the specified server farm.
     * Submit a reboot request for a worker machine in the specified server farm.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of server farm
     * @param workerName Name of worker machine, typically starts with RD
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> rebootWorkerWithServiceResponseAsync(String resourceGroupName, String name, String workerName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (workerName == null) {
            throw new IllegalArgumentException("Parameter workerName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-09-01";
        return service.rebootWorker(resourceGroupName, name, workerName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = rebootWorkerDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> rebootWorkerDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;AppServicePlanInner&gt; object if successful.
     */
    public PagedList<AppServicePlanInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<AppServicePlanInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AppServicePlanInner>(response.getBody()) {
            @Override
            public Page<AppServicePlanInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<AppServicePlanInner>> listNextAsync(final String nextPageLink, final ServiceCall<List<AppServicePlanInner>> serviceCall, final ListOperationCallback<AppServicePlanInner> serviceCallback) {
        return AzureServiceCall.create(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<Page<AppServicePlanInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Page<AppServicePlanInner>>() {
                @Override
                public Page<AppServicePlanInner> call(ServiceResponse<Page<AppServicePlanInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(ServiceResponse<Page<AppServicePlanInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all App Service Plans for a subcription.
     * Gets all App Service Plans for a subcription.
     *
    ServiceResponse<PageImpl<AppServicePlanInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;AppServicePlanInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AppServicePlanInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AppServicePlanInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AppServicePlanInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<AppServicePlanInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<AppServicePlanInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;AppServicePlanInner&gt; object if successful.
     */
    public PagedList<AppServicePlanInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<AppServicePlanInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<AppServicePlanInner>(response.getBody()) {
            @Override
            public Page<AppServicePlanInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<AppServicePlanInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceCall<List<AppServicePlanInner>> serviceCall, final ListOperationCallback<AppServicePlanInner> serviceCallback) {
        return AzureServiceCall.create(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<Page<AppServicePlanInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Page<AppServicePlanInner>>() {
                @Override
                public Page<AppServicePlanInner> call(ServiceResponse<Page<AppServicePlanInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;AppServicePlanInner&gt; object
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<AppServicePlanInner>>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(ServiceResponse<Page<AppServicePlanInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets collection of App Service Plans in a resource group for a given subscription.
     * Gets collection of App Service Plans in a resource group for a given subscription.
     *
    ServiceResponse<PageImpl<AppServicePlanInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;AppServicePlanInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<AppServicePlanInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listByResourceGroupNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<AppServicePlanInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<AppServicePlanInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AppServicePlanInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<AppServicePlanInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<AppServicePlanInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<AppServicePlanInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<AppServicePlanInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefintionsNext(final String nextPageLink) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefintionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefintionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefintionsNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefintionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefintionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefintionsNextAsync(final String nextPageLink) {
        return listMetricDefintionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefintionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefintionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefintionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List of metrics that can be queried for an App Service Plan.
     * List of metrics that can be queried for an App Service Plan.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefintionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricDefintionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefintionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefintionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink) {
        return listMetricsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Queries for App Serice Plan metrics.
     * Queries for App Serice Plan metrics.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listWebAppsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listWebAppsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listWebAppsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listWebAppsNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listWebAppsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listWebAppsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listWebAppsNextAsync(final String nextPageLink) {
        return listWebAppsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsNextWithServiceResponseAsync(final String nextPageLink) {
        return listWebAppsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listWebAppsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets list of Apps associated with an App Service Plan.
     * Gets list of Apps associated with an App Service Plan.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWebAppsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listWebAppsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listWebAppsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listWebAppsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
