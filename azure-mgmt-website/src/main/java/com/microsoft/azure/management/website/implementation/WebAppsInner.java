/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.website.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceCall;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.website.CsmPublishingProfileOptions;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in WebApps.
 */
public final class WebAppsInner {
    /** The Retrofit service to perform REST calls. */
    private WebAppsService service;
    /** The service client containing this operation class. */
    private WebSiteManagementClientImpl client;

    /**
     * Initializes an instance of WebAppsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public WebAppsInner(Retrofit retrofit, WebSiteManagementClientImpl client) {
        this.service = retrofit.create(WebAppsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for WebApps to be
     * used by Retrofit to perform actually REST calls.
     */
    interface WebAppsService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> list(@Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/deletedSites")
        Observable<Response<ResponseBody>> listDeleted(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites")
        Observable<Response<ResponseBody>> listByResourceGroup(@Path("resourceGroupName") String resourceGroupName, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("includeSlots") Boolean includeSlots, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> get(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> createOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}")
        Observable<Response<ResponseBody>> beginCreateOrUpdate(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> delete(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostname(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigToProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup")
        Observable<Response<ResponseBody>> backup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups")
        Observable<Response<ResponseBody>> listBackups(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatus(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackup(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestore(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list")
        Observable<Response<ResponseBody>> listAuthSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStrings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadata(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentials(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> listSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames")
        Observable<Response<ResponseBody>> updateSlotConfigurationNames(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SlotConfigNamesResourceInner slotConfigNames, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> getConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web")
        Observable<Response<ResponseBody>> updateConfiguration(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments")
        Observable<Response<ResponseBody>> listDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindings(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBinding(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeys(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiers(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> listInstanceDeployments(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeployment(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable")
        Observable<Response<ResponseBody>> isCloneable(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitions(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics")
        Observable<Response<ResponseBody>> listMetrics(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> migrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptionsInner options, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate")
        Observable<Response<ResponseBody>> beginMigrateStorage(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("subscriptionName") String subscriptionName, @Body StorageMigrationOptionsInner options, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> migrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequestInner migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql")
        Observable<Response<ResponseBody>> beginMigrateMySql(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body MigrateMySqlRequestInner migrationRequestEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeatures(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTrace(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPassword(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getOperation(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCounters(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlag(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOns(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOn(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecrets(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> recover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/recover")
        Observable<Response<ResponseBody>> beginRecover(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetProductionSlotConfig(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart")
        Observable<Response<ResponseBody>> restart(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots")
        Observable<Response<ResponseBody>> listSlots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> getSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("propertiesToInclude") String propertiesToInclude, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> createOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}")
        Observable<Response<ResponseBody>> beginCreateOrUpdateSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteInner siteEnvelope, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("skipCustomDomainVerification") Boolean skipCustomDomainVerification, @Query("forceDnsRegistration") Boolean forceDnsRegistration, @Query("ttlInSeconds") String ttlInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("deleteMetrics") Boolean deleteMetrics, @Query("deleteEmptyServerFarm") Boolean deleteEmptyServerFarm, @Query("skipDnsRegistration") Boolean skipDnsRegistration, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname")
        Observable<Response<ResponseBody>> analyzeCustomHostnameSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("hostName") String hostName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig")
        Observable<Response<ResponseBody>> applySlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup")
        Observable<Response<ResponseBody>> backupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups")
        Observable<Response<ResponseBody>> listBackupsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/discover")
        Observable<Response<ResponseBody>> discoverRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}")
        Observable<Response<ResponseBody>> getBackupStatusSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list")
        Observable<Response<ResponseBody>> listBackupStatusSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> restoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore")
        Observable<Response<ResponseBody>> beginRestoreSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("backupId") String backupId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RestoreRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings")
        Observable<Response<ResponseBody>> updateApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner appSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list")
        Observable<Response<ResponseBody>> listApplicationSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings")
        Observable<Response<ResponseBody>> updateAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteAuthSettingsInner siteAuthSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list")
        Observable<Response<ResponseBody>> listAuthSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup")
        Observable<Response<ResponseBody>> updateBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body BackupRequestInner request, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list")
        Observable<Response<ResponseBody>> getBackupConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings")
        Observable<Response<ResponseBody>> updateConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body ConnectionStringDictionaryInner connectionStrings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list")
        Observable<Response<ResponseBody>> listConnectionStringsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> getDiagnosticLogsConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs")
        Observable<Response<ResponseBody>> updateDiagnosticLogsConfigSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteLogsConfigInner siteLogsConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata")
        Observable<Response<ResponseBody>> updateMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body StringDictionaryInner metadata, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list")
        Observable<Response<ResponseBody>> listMetadataSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> listPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list")
        Observable<Response<ResponseBody>> beginListPublishingCredentialsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings")
        Observable<Response<ResponseBody>> updateSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PushSettingsInner pushSettings, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list")
        Observable<Response<ResponseBody>> listSitePushSettingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> getConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> createOrUpdateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web")
        Observable<Response<ResponseBody>> updateConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteConfigInner siteConfig, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments")
        Observable<Response<ResponseBody>> listDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> getDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}")
        Observable<Response<ResponseBody>> createDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings")
        Observable<Response<ResponseBody>> listHostNameBindingsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> getHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}")
        Observable<Response<ResponseBody>> createOrUpdateHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("hostName") String hostName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HostNameBindingInner hostNameBinding, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHostNameBindingSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("hostName") String hostName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> getHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> createOrUpdateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}")
        Observable<Response<ResponseBody>> updateHybridConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body HybridConnectionInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys")
        Observable<Response<ResponseBody>> listHybridConnectionKeysSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("namespaceName") String namespaceName, @Path("relayName") String relayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays")
        Observable<Response<ResponseBody>> listHybridConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection")
        Observable<Response<ResponseBody>> listRelayServiceConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> getRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> createOrUpdateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}")
        Observable<Response<ResponseBody>> updateRelayServiceConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("entityName") String entityName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body RelayServiceConnectionEntityInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances")
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments")
        Observable<Response<ResponseBody>> listInstanceDeploymentsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> getInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}")
        Observable<Response<ResponseBody>> createInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Body DeploymentInner deployment, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/deployments/{id}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteInstanceDeploymentSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("id") String id, @Path("slot") String slot, @Path("instanceId") String instanceId, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable")
        Observable<Response<ResponseBody>> isCloneableSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions")
        Observable<Response<ResponseBody>> listMetricDefinitionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics")
        Observable<Response<ResponseBody>> listMetricsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("details") Boolean details, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}")
        Observable<Response<ResponseBody>> listNetworkFeaturesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("view") String view, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start")
        Observable<Response<ResponseBody>> startWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("durationInSeconds") Integer durationInSeconds, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop")
        Observable<Response<ResponseBody>> stopWebSiteNetworkTraceSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword")
        Observable<Response<ResponseBody>> generateNewSitePublishingPasswordSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/operationresults/{operationId}")
        Observable<Response<ResponseBody>> getOperationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("operationId") String operationId, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters")
        Observable<Response<ResponseBody>> listPerfMonCountersSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging")
        Observable<Response<ResponseBody>> getSitePhpErrorLogFlagSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons")
        Observable<Response<ResponseBody>> listPremierAddOnsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> getPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}")
        Observable<Response<ResponseBody>> addPremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body PremierAddOnRequestInner premierAddOn, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePremierAddOnSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("premierAddOnName") String premierAddOnName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml")
        @Streaming
        Observable<Response<ResponseBody>> listPublishingProfileXmlWithSecretsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CsmPublishingProfileOptions options, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> recoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/recover")
        Observable<Response<ResponseBody>> beginRecoverSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSiteRecoveryEntityInner recoveryEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig")
        Observable<Response<ResponseBody>> resetSlotConfigurationSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart")
        Observable<Response<ResponseBody>> restartSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("softRestart") Boolean softRestart, @Query("synchronous") Boolean synchronous, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots")
        Observable<Response<ResponseBody>> listSnapshotsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSourceControlSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start")
        Observable<Response<ResponseBody>> startSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop")
        Observable<Response<ResponseBody>> stopSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync")
        Observable<Response<ResponseBody>> syncRepositorySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages")
        Observable<Response<ResponseBody>> listUsagesSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnectionsSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnectionSlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGatewaySlot(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("slot") String slot, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> swapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap")
        Observable<Response<ResponseBody>> beginSwapSlotWithProduction(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body CsmSlotEntityInner slotSwapEntity, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots")
        Observable<Response<ResponseBody>> listSnapshots(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> getSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> createOrUpdateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web")
        Observable<Response<ResponseBody>> updateSourceControl(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Body SiteSourceControlInner siteSourceControl, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start")
        Observable<Response<ResponseBody>> start(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop")
        Observable<Response<ResponseBody>> stop(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync")
        Observable<Response<ResponseBody>> syncRepository(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages")
        Observable<Response<ResponseBody>> listUsages(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("$filter") String filter, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections")
        Observable<Response<ResponseBody>> listVnetConnections(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> getVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}")
        Observable<Response<ResponseBody>> updateVnetConnection(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("subscriptionId") String subscriptionId, @Body VnetInfoInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> getVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> createOrUpdateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}")
        Observable<Response<ResponseBody>> updateVnetConnectionGateway(@Path("resourceGroupName") String resourceGroupName, @Path("name") String name, @Path("vnetName") String vnetName, @Path("gatewayName") String gatewayName, @Path("subscriptionId") String subscriptionId, @Body VnetGatewayInner connectionEnvelope, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listDeletedNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listByResourceGroupNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listBackupsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listHostNameBindingsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listInstanceIdentifiersNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listInstanceDeploymentsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricDefinitionsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listPerfMonCountersNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSlotsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listBackupsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listHostNameBindingsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listInstanceIdentifiersSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listInstanceDeploymentsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricDefinitionsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listMetricsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listPerfMonCountersSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSnapshotsSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listUsagesSlotNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("{nextLink}")
        Observable<Response<ResponseBody>> getSlotsDifferencesFromProductionNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listSnapshotsNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("{nextLink}")
        Observable<Response<ResponseBody>> listUsagesNext(@Path(value = "nextLink", encoded = true) String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> list() {
        ServiceResponse<Page<SiteInner>> response = listSinglePageAsync().toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listAsync(final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listSinglePageAsync(),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listWithServiceResponseAsync() {
        return listSinglePageAsync()
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSinglePageAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.list(this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> listDeleted(final String resourceGroupName) {
        ServiceResponse<Page<DeletedSiteInner>> response = listDeletedSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return listDeletedNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> listDeletedAsync(final String resourceGroupName, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeletedSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return listDeletedNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> listDeletedAsync(final String resourceGroupName) {
        return listDeletedWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedWithServiceResponseAsync(final String resourceGroupName) {
        return listDeletedSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeletedNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String propertiesToInclude = null;
        return service.listDeleted(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = listDeletedDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> listDeleted(final String resourceGroupName, final String propertiesToInclude) {
        ServiceResponse<Page<DeletedSiteInner>> response = listDeletedSinglePageAsync(resourceGroupName, propertiesToInclude).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return listDeletedNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> listDeletedAsync(final String resourceGroupName, final String propertiesToInclude, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeletedSinglePageAsync(resourceGroupName, propertiesToInclude),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return listDeletedNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> listDeletedAsync(final String resourceGroupName, final String propertiesToInclude) {
        return listDeletedWithServiceResponseAsync(resourceGroupName, propertiesToInclude)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedWithServiceResponseAsync(final String resourceGroupName, final String propertiesToInclude) {
        return listDeletedSinglePageAsync(resourceGroupName, propertiesToInclude)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeletedNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param propertiesToInclude Additional web app properties included in the response
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedSinglePageAsync(final String resourceGroupName, final String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDeleted(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = listDeletedDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> listDeletedDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listByResourceGroupSinglePageAsync(resourceGroupName),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName) {
        return listByResourceGroupSinglePageAsync(resourceGroupName)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String propertiesToInclude = null;
        final Boolean includeSlots = null;
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSlots, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroup(final String resourceGroupName, final String propertiesToInclude, final Boolean includeSlots) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupSinglePageAsync(resourceGroupName, propertiesToInclude, includeSlots).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final String propertiesToInclude, final Boolean includeSlots, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listByResourceGroupSinglePageAsync(resourceGroupName, propertiesToInclude, includeSlots),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupAsync(final String resourceGroupName, final String propertiesToInclude, final Boolean includeSlots) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName, propertiesToInclude, includeSlots)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param resourceGroupName Name of resource group
     * @param propertiesToInclude Additional web app properties included in the response
     * @param includeSlots Whether or not to include deployments slots in results
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupWithServiceResponseAsync(final String resourceGroupName, final String propertiesToInclude, final Boolean includeSlots) {
        return listByResourceGroupSinglePageAsync(resourceGroupName, propertiesToInclude, includeSlots)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude Additional web app properties included in the response
    ServiceResponse<PageImpl<SiteInner>> * @param includeSlots Whether or not to include deployments slots in results
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupSinglePageAsync(final String resourceGroupName, final String propertiesToInclude, final Boolean includeSlots) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listByResourceGroup(resourceGroupName, this.client.subscriptionId(), propertiesToInclude, includeSlots, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteInner object if successful.
     */
    public SiteInner get(String resourceGroupName, String name) {
        return getWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getAsync(String resourceGroupName, String name, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getAsync(String resourceGroupName, String name) {
        return getWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String propertiesToInclude = null;
        return service.get(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the SiteInner object if successful.
     */
    public SiteInner get(String resourceGroupName, String name, String propertiesToInclude) {
        return getWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getAsync(String resourceGroupName, String name, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getAsync(String resourceGroupName, String name, String propertiesToInclude) {
        return getWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getWithServiceResponseAsync(String resourceGroupName, String name, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.get(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object  if successful.
     */
    public SiteInner createOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdate(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, name, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateWithServiceResponseAsync(String resourceGroupName, String name, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdate(resourceGroupName, name, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object delete(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAsync(String resourceGroupName, String name) {
        return deleteWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        final Boolean skipDnsRegistration = null;
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the Object object if successful.
     */
    public Object delete(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration), serviceCallback);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteWithServiceResponseAsync(resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteWithServiceResponseAsync(String resourceGroupName, String name, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.delete(resourceGroupName, name, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceCall.create(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String hostName = null;
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Custom hostname
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostname(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().getBody();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Custom hostname
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceCall.create(analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Custom hostname
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameAsync(String resourceGroupName, String name, String hostName) {
        return analyzeCustomHostnameWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Custom hostname
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.analyzeCustomHostname(resourceGroupName, name, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CustomHostnameAnalysisResultInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the Object object if successful.
     */
    public Object applySlotConfigToProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<Object> applySlotConfigToProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigToProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigToProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.applySlotConfigToProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigToProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigToProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backup(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return backupWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.backup(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackups(final String resourceGroupName, final String name) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listBackupsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsAsync(final String resourceGroupName, final String name) {
        return listBackupsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listBackupsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listBackups(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestore(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        return discoverRestoreWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreWithServiceResponseAsync(String resourceGroupName, String name, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.discoverRestore(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatus(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusAsync(String resourceGroupName, String name, String backupId) {
        return getBackupStatusWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupStatus(resourceGroupName, name, backupId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner deleteBackup(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).toBlocking().single().getBody();
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupAsync(String resourceGroupName, String name, String backupId, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> deleteBackupAsync(String resourceGroupName, String name, String backupId) {
        return deleteBackupWithServiceResponseAsync(resourceGroupName, name, backupId).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupWithServiceResponseAsync(String resourceGroupName, String name, String backupId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackup(resourceGroupName, name, backupId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecrets(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        return listBackupStatusSecretsWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsWithServiceResponseAsync(String resourceGroupName, String name, String backupId, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.listBackupStatusSecrets(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().last().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return restoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.restore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestore(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).toBlocking().single().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        return beginRestoreWithServiceResponseAsync(resourceGroupName, name, backupId, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreWithServiceResponseAsync(String resourceGroupName, String name, String backupId, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.beginRestore(resourceGroupName, name, backupId, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettings(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        return updateApplicationSettingsWithServiceResponseAsync(resourceGroupName, name, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        Validator.validate(appSettings);
        final String apiVersion = "2016-08-01";
        return service.updateApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), appSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettings(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsAsync(String resourceGroupName, String name) {
        return listApplicationSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listApplicationSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettings(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsWithServiceResponseAsync(resourceGroupName, name, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        final String apiVersion = "2016-08-01";
        return service.updateAuthSettings(resourceGroupName, name, this.client.subscriptionId(), siteAuthSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner listAuthSettings(String resourceGroupName, String name) {
        return listAuthSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listAuthSettingsAsync(String resourceGroupName, String name, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listAuthSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> listAuthSettingsAsync(String resourceGroupName, String name) {
        return listAuthSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listAuthSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listAuthSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listAuthSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listAuthSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfiguration(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).toBlocking().single().getBody();
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationAsync(String resourceGroupName, String name, BackupRequestInner request) {
        return updateBackupConfigurationWithServiceResponseAsync(resourceGroupName, name, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.updateBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object deleteBackupConfiguration(String resourceGroupName, String name) {
        return deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> deleteBackupConfigurationAsync(String resourceGroupName, String name) {
        return deleteBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfiguration(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationAsync(String resourceGroupName, String name) {
        return getBackupConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStrings(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).toBlocking().single().getBody();
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsWithServiceResponseAsync(resourceGroupName, name, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        final String apiVersion = "2016-08-01";
        return service.updateConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), connectionStrings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStrings(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listConnectionStringsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsAsync(String resourceGroupName, String name) {
        return listConnectionStringsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConnectionStrings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfiguration(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationAsync(String resourceGroupName, String name) {
        return getDiagnosticLogsConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDiagnosticLogsConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfig(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigWithServiceResponseAsync(resourceGroupName, name, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigWithServiceResponseAsync(String resourceGroupName, String name, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        final String apiVersion = "2016-08-01";
        return service.updateDiagnosticLogsConfig(resourceGroupName, name, this.client.subscriptionId(), siteLogsConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadata(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        return updateMetadataWithServiceResponseAsync(resourceGroupName, name, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataWithServiceResponseAsync(String resourceGroupName, String name, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        Validator.validate(metadata);
        final String apiVersion = "2016-08-01";
        return service.updateMetadata(resourceGroupName, name, this.client.subscriptionId(), metadata, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadata(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listMetadataWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataAsync(String resourceGroupName, String name) {
        return listMetadataWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetadata(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentials(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().last().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsAsync(String resourceGroupName, String name) {
        return listPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentials(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsAsync(String resourceGroupName, String name) {
        return beginListPublishingCredentialsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.beginListPublishingCredentials(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettings(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        return updateSitePushSettingsWithServiceResponseAsync(resourceGroupName, name, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param pushSettings Push settings associated with web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        final String apiVersion = "2016-08-01";
        return service.updateSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), pushSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PushSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettings(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceCall.create(listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsAsync(String resourceGroupName, String name) {
        return listSitePushSettingsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSitePushSettings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PushSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner listSlotConfigurationNames(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> listSlotConfigurationNamesAsync(String resourceGroupName, String name) {
        return listSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     * Gets the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> listSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = listSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> listSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the SlotConfigNamesResourceInner object if successful.
     */
    public SlotConfigNamesResourceInner updateSlotConfigurationNames(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).toBlocking().single().getBody();
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames, final ServiceCallback<SlotConfigNamesResourceInner> serviceCallback) {
        return ServiceCall.create(updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames), serviceCallback);
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<SlotConfigNamesResourceInner> updateSlotConfigurationNamesAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        return updateSlotConfigurationNamesWithServiceResponseAsync(resourceGroupName, name, slotConfigNames).map(new Func1<ServiceResponse<SlotConfigNamesResourceInner>, SlotConfigNamesResourceInner>() {
            @Override
            public SlotConfigNamesResourceInner call(ServiceResponse<SlotConfigNamesResourceInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     * Updates the names of application settings and connection string that remain with the slot during swap operation.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotConfigNames Request body containing the names of application settings and connection strings
     * @return the observable to the SlotConfigNamesResourceInner object
     */
    public Observable<ServiceResponse<SlotConfigNamesResourceInner>> updateSlotConfigurationNamesWithServiceResponseAsync(String resourceGroupName, String name, SlotConfigNamesResourceInner slotConfigNames) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotConfigNames == null) {
            throw new IllegalArgumentException("Parameter slotConfigNames is required and cannot be null.");
        }
        Validator.validate(slotConfigNames);
        final String apiVersion = "2016-08-01";
        return service.updateSlotConfigurationNames(resourceGroupName, name, this.client.subscriptionId(), slotConfigNames, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SlotConfigNamesResourceInner>>>() {
                @Override
                public Observable<ServiceResponse<SlotConfigNamesResourceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SlotConfigNamesResourceInner> clientResponse = updateSlotConfigurationNamesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SlotConfigNamesResourceInner> updateSlotConfigurationNamesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SlotConfigNamesResourceInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SlotConfigNamesResourceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner getConfiguration(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getConfigurationAsync(String resourceGroupName, String name, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getConfigurationWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> getConfigurationAsync(String resourceGroupName, String name) {
        return getConfigurationWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getConfigurationWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfiguration(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner createOrUpdateConfiguration(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> createOrUpdateConfigurationAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return createOrUpdateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner updateConfiguration(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> updateConfigurationAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        return updateConfigurationWithServiceResponseAsync(resourceGroupName, name, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateConfigurationWithServiceResponseAsync(String resourceGroupName, String name, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.updateConfiguration(resourceGroupName, name, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateConfigurationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeployments(final String resourceGroupName, final String name) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeploymentsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsAsync(final String resourceGroupName, final String name) {
        return listDeploymentsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listDeploymentsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDeployments(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeployment(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentAsync(String resourceGroupName, String name, String id) {
        return getDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDeployment(resourceGroupName, name, id, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeployment(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        return createDeploymentWithServiceResponseAsync(resourceGroupName, name, id, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createDeployment(resourceGroupName, name, id, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the Object object if successful.
     */
    public Object deleteDeployment(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentAsync(String resourceGroupName, String name, String id, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id), serviceCallback);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDeploymentAsync(String resourceGroupName, String name, String id) {
        return deleteDeploymentWithServiceResponseAsync(resourceGroupName, name, id).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDeployment(resourceGroupName, name, id, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindings(final String resourceGroupName, final String name) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            listHostNameBindingsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listHostNameBindingsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHostNameBindings(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBinding(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().getBody();
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return getHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBinding(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).toBlocking().single().getBody();
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), hostNameBinding, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the Object object if successful.
     */
    public Object deleteHostNameBinding(String resourceGroupName, String name, String hostName) {
        return deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).toBlocking().single().getBody();
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<Object> deleteHostNameBindingAsync(String resourceGroupName, String name, String hostName) {
        return deleteHostNameBindingWithServiceResponseAsync(resourceGroupName, name, hostName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteHostNameBindingWithServiceResponseAsync(String resourceGroupName, String name, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHostNameBinding(resourceGroupName, name, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteHostNameBindingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteHostNameBindingDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return getHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the Object object if successful.
     */
    public Object deleteHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the Object object
     */
    public Observable<Object> deleteHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return deleteHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnection(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateHybridConnection(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the Object object if successful.
     */
    public Object listHybridConnectionKeys(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).toBlocking().single().getBody();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the Object object
     */
    public Observable<Object> listHybridConnectionKeysAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        return listHybridConnectionKeysWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listHybridConnectionKeysWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listHybridConnectionKeysDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listHybridConnectionKeysDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnections(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsAsync(String resourceGroupName, String name) {
        return listHybridConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnections(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsAsync(String resourceGroupName, String name) {
        return listRelayServiceConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listRelayServiceConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return getRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the Object object if successful.
     */
    public Object deleteRelayServiceConnection(String resourceGroupName, String name, String entityName) {
        return deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).toBlocking().single().getBody();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the Object object
     */
    public Observable<Object> deleteRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName) {
        return deleteRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnection(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionWithServiceResponseAsync(resourceGroupName, name, entityName, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionWithServiceResponseAsync(String resourceGroupName, String name, String entityName, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateRelayServiceConnection(resourceGroupName, name, entityName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiers(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceIdentifiersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listInstanceIdentifiersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceIdentifiers(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeployments(final String resourceGroupName, final String name, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceDeploymentsWithServiceResponseAsync(resourceGroupName, name, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsWithServiceResponseAsync(final String resourceGroupName, final String name, final String instanceId) {
        return listInstanceDeploymentsSinglePageAsync(resourceGroupName, name, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSinglePageAsync(final String resourceGroupName, final String name, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceDeployments(resourceGroupName, name, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return getInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeployment(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the Object object if successful.
     */
    public Object deleteInstanceDeployment(String resourceGroupName, String name, String id, String instanceId) {
        return deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<Object> deleteInstanceDeploymentAsync(String resourceGroupName, String name, String id, String instanceId) {
        return deleteInstanceDeploymentWithServiceResponseAsync(resourceGroupName, name, id, instanceId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentWithServiceResponseAsync(String resourceGroupName, String name, String id, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteInstanceDeployment(resourceGroupName, name, id, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneable(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isCloneableWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableAsync(String resourceGroupName, String name) {
        return isCloneableWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.isCloneable(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefinitions(final String resourceGroupName, final String name) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefinitionsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefinitionsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefinitionsAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricDefinitionsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricDefinitions(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefinitionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefinitionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listMetricsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean details = null;
        final String filter = null;
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetrics(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSinglePageAsync(resourceGroupName, name, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSinglePageAsync(resourceGroupName, name, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsWithServiceResponseAsync(resourceGroupName, name, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        return listMetricsSinglePageAsync(resourceGroupName, name, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSinglePageAsync(final String resourceGroupName, final String name, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetrics(resourceGroupName, name, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner migrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options).toBlocking().last().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceCall.create(migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the observable for the request
     */
    public Observable<StorageMigrationResponseInner> migrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        return migrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the observable for the request
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> migrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (options == null) {
            throw new IllegalArgumentException("Parameter options is required and cannot be null.");
        }
        Validator.validate(options);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.migrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, options, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<StorageMigrationResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the StorageMigrationResponseInner object if successful.
     */
    public StorageMigrationResponseInner beginMigrateStorage(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options).toBlocking().single().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options, final ServiceCallback<StorageMigrationResponseInner> serviceCallback) {
        return ServiceCall.create(beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<StorageMigrationResponseInner> beginMigrateStorageAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        return beginMigrateStorageWithServiceResponseAsync(resourceGroupName, name, subscriptionName, options).map(new Func1<ServiceResponse<StorageMigrationResponseInner>, StorageMigrationResponseInner>() {
            @Override
            public StorageMigrationResponseInner call(ServiceResponse<StorageMigrationResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param subscriptionName Azure subscription
     * @param options Migration options
     * @return the observable to the StorageMigrationResponseInner object
     */
    public Observable<ServiceResponse<StorageMigrationResponseInner>> beginMigrateStorageWithServiceResponseAsync(String resourceGroupName, String name, String subscriptionName, StorageMigrationOptionsInner options) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (subscriptionName == null) {
            throw new IllegalArgumentException("Parameter subscriptionName is required and cannot be null.");
        }
        if (options == null) {
            throw new IllegalArgumentException("Parameter options is required and cannot be null.");
        }
        Validator.validate(options);
        final String apiVersion = "2016-08-01";
        return service.beginMigrateStorage(resourceGroupName, name, this.client.subscriptionId(), subscriptionName, options, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StorageMigrationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<StorageMigrationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StorageMigrationResponseInner> clientResponse = beginMigrateStorageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StorageMigrationResponseInner> beginMigrateStorageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StorageMigrationResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StorageMigrationResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the OperationInner object if successful.
     */
    public OperationInner migrateMySql(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().last().getBody();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceCall.create(migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the observable for the request
     */
    public Observable<OperationInner> migrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return migrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the observable for the request
     */
    public Observable<ServiceResponse<OperationInner>> migrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.migrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<OperationInner>() { }.getType());
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the OperationInner object if successful.
     */
    public OperationInner beginMigrateMySql(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).toBlocking().single().getBody();
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope, final ServiceCallback<OperationInner> serviceCallback) {
        return ServiceCall.create(beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope), serviceCallback);
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the observable to the OperationInner object
     */
    public Observable<OperationInner> beginMigrateMySqlAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        return beginMigrateMySqlWithServiceResponseAsync(resourceGroupName, name, migrationRequestEnvelope).map(new Func1<ServiceResponse<OperationInner>, OperationInner>() {
            @Override
            public OperationInner call(ServiceResponse<OperationInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Migrates a local (in-app) MySql database to a remote MySql database.
     * Migrates a local (in-app) MySql database to a remote MySql database.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param migrationRequestEnvelope MySql migration options
     * @return the observable to the OperationInner object
     */
    public Observable<ServiceResponse<OperationInner>> beginMigrateMySqlWithServiceResponseAsync(String resourceGroupName, String name, MigrateMySqlRequestInner migrationRequestEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (migrationRequestEnvelope == null) {
            throw new IllegalArgumentException("Parameter migrationRequestEnvelope is required and cannot be null.");
        }
        Validator.validate(migrationRequestEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginMigrateMySql(resourceGroupName, name, this.client.subscriptionId(), migrationRequestEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<OperationInner>>>() {
                @Override
                public Observable<ServiceResponse<OperationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<OperationInner> clientResponse = beginMigrateMySqlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<OperationInner> beginMigrateMySqlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<OperationInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<OperationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeatures(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).toBlocking().single().getBody();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesAsync(String resourceGroupName, String name, String view) {
        return listNetworkFeaturesWithServiceResponseAsync(resourceGroupName, name, view).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesWithServiceResponseAsync(String resourceGroupName, String name, String view) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listNetworkFeatures(resourceGroupName, name, view, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Integer durationInSeconds = null;
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTrace(String resourceGroupName, String name, Integer durationInSeconds) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds).toBlocking().single().getBody();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param durationInSeconds The duration to keep capturing in seconds
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceAsync(String resourceGroupName, String name, Integer durationInSeconds) {
        return startWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name, durationInSeconds).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name, Integer durationInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), durationInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<String, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTrace(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceAsync(String resourceGroupName, String name) {
        return stopWebSiteNetworkTraceWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopWebSiteNetworkTrace(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<String, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object generateNewSitePublishingPassword(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> generateNewSitePublishingPasswordAsync(String resourceGroupName, String name) {
        return generateNewSitePublishingPasswordWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.generateNewSitePublishingPassword(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the Object object if successful.
     */
    public Object getOperation(String resourceGroupName, String name, String operationId) {
        return getOperationWithServiceResponseAsync(resourceGroupName, name, operationId).toBlocking().single().getBody();
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getOperationAsync(String resourceGroupName, String name, String operationId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getOperationWithServiceResponseAsync(resourceGroupName, name, operationId), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the observable to the Object object
     */
    public Observable<Object> getOperationAsync(String resourceGroupName, String name, String operationId) {
        return getOperationWithServiceResponseAsync(resourceGroupName, name, operationId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getOperationWithServiceResponseAsync(String resourceGroupName, String name, String operationId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getOperation(resourceGroupName, name, operationId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getOperationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCounters(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listPerfMonCountersSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPerfMonCounters(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<PerfMonResponseInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the List&lt;Object&gt; object if successful.
     */
    public List<Object> getSitePhpErrorLogFlag(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<Object>> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name, final ServiceCallback<List<Object>> serviceCallback) {
        return ServiceCall.create(getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;Object&gt; object
     */
    public Observable<List<Object>> getSitePhpErrorLogFlagAsync(String resourceGroupName, String name) {
        return getSitePhpErrorLogFlagWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<Object>>, List<Object>>() {
            @Override
            public List<Object> call(ServiceResponse<List<Object>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the List&lt;Object&gt; object
     */
    public Observable<ServiceResponse<List<Object>>> getSitePhpErrorLogFlagWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSitePhpErrorLogFlag(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Object>>>>() {
                @Override
                public Observable<ServiceResponse<List<Object>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Object>> clientResponse = getSitePhpErrorLogFlagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Object>> getSitePhpErrorLogFlagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<Object>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Object>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @return the Object object if successful.
     */
    public Object listPremierAddOns(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listPremierAddOnsAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @return the observable to the Object object
     */
    public Observable<Object> listPremierAddOnsAsync(String resourceGroupName, String name) {
        return listPremierAddOnsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listPremierAddOnsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPremierAddOns(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listPremierAddOnsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listPremierAddOnsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the Object object if successful.
     */
    public Object getPremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().getBody();
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the observable to the Object object
     */
    public Observable<Object> getPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return getPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param premierAddOn Premier add on request
     * @return the Object object if successful.
     */
    public Object addPremierAddOn(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).toBlocking().single().getBody();
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param premierAddOn Premier add on request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn), serviceCallback);
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param premierAddOn Premier add on request
     * @return the observable to the Object object
     */
    public Observable<Object> addPremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        return addPremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, premierAddOn).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param premierAddOn Premier add on request
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addPremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        final String apiVersion = "2016-08-01";
        return service.addPremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), premierAddOn, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addPremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addPremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the Object object if successful.
     */
    public Object deletePremierAddOn(String resourceGroupName, String name, String premierAddOnName) {
        return deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).toBlocking().single().getBody();
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName), serviceCallback);
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the observable to the Object object
     */
    public Observable<Object> deletePremierAddOnAsync(String resourceGroupName, String name, String premierAddOnName) {
        return deletePremierAddOnWithServiceResponseAsync(resourceGroupName, name, premierAddOnName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deletePremierAddOnWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deletePremierAddOn(resourceGroupName, name, premierAddOnName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deletePremierAddOnDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deletePremierAddOnDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecrets(String resourceGroupName, String name, String format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsAsync(String resourceGroupName, String name, String format) {
        return listPublishingProfileXmlWithSecretsWithServiceResponseAsync(resourceGroupName, name, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsWithServiceResponseAsync(String resourceGroupName, String name, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listPublishingProfileXmlWithSecrets(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner recover(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().last().getBody();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RecoverResponseInner> recoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceCall.create(recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<RecoverResponseInner> recoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RecoverResponseInner>> recoverWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.recover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RecoverResponseInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner beginRecover(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).toBlocking().single().getBody();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RecoverResponseInner> beginRecoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceCall.create(beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<RecoverResponseInner> beginRecoverAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverWithServiceResponseAsync(resourceGroupName, name, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<ServiceResponse<RecoverResponseInner>> beginRecoverWithServiceResponseAsync(String resourceGroupName, String name, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        return service.beginRecover(resourceGroupName, name, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RecoverResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RecoverResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RecoverResponseInner> clientResponse = beginRecoverDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RecoverResponseInner> beginRecoverDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RecoverResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RecoverResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object resetProductionSlotConfig(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetProductionSlotConfigAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> resetProductionSlotConfigAsync(String resourceGroupName, String name) {
        return resetProductionSlotConfigWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetProductionSlotConfigWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.resetProductionSlotConfig(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetProductionSlotConfigDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetProductionSlotConfigDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object restart(String resourceGroupName, String name) {
        return restartWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> restartAsync(String resourceGroupName, String name) {
        return restartWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the Object object if successful.
     */
    public Object restart(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<Object> restartAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        return restartWithServiceResponseAsync(resourceGroupName, name, softRestart, synchronous).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartWithServiceResponseAsync(String resourceGroupName, String name, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.restart(resourceGroupName, name, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SiteInner>> response = listSlotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listSlotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name) {
        return listSlotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSlotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String propertiesToInclude = null;
        return service.listSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlots(final String resourceGroupName, final String name, final String propertiesToInclude) {
        ServiceResponse<Page<SiteInner>> response = listSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        return listSlotsWithServiceResponseAsync(resourceGroupName, name, propertiesToInclude)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param propertiesToInclude List of app properties to include in the response
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsWithServiceResponseAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        return listSlotsSinglePageAsync(resourceGroupName, name, propertiesToInclude)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInner>> * @param propertiesToInclude List of app properties to include in the response
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsSinglePageAsync(final String resourceGroupName, final String name, final String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSlots(resourceGroupName, name, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteInner object if successful.
     */
    public SiteInner getSlot(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String propertiesToInclude = null;
        return service.getSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the SiteInner object if successful.
     */
    public SiteInner getSlot(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude).toBlocking().single().getBody();
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(getSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude), serviceCallback);
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> getSlotAsync(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        return getSlotWithServiceResponseAsync(resourceGroupName, name, slot, propertiesToInclude).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get details of a web app.
     * Get details of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param propertiesToInclude Additional web app properties included in the response
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> getSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String propertiesToInclude) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSlot(resourceGroupName, name, slot, this.client.subscriptionId(), propertiesToInclude, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = getSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> getSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object  if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }
    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner createOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().last().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<SiteInner> createOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return createOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<SiteInner>> createOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.createOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<SiteInner>() { }.getType());
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        final Boolean skipDnsRegistration = null;
        final Boolean skipCustomDomainVerification = null;
        final Boolean forceDnsRegistration = null;
        final String ttlInSeconds = null;
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the SiteInner object if successful.
     */
    public SiteInner beginCreateOrUpdateSlot(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds, final ServiceCallback<SiteInner> serviceCallback) {
        return ServiceCall.create(beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<SiteInner> beginCreateOrUpdateSlotAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        return beginCreateOrUpdateSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds).map(new Func1<ServiceResponse<SiteInner>, SiteInner>() {
            @Override
            public SiteInner call(ServiceResponse<SiteInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteEnvelope Details of web app if it exists already
     * @param skipDnsRegistration If true web app hostname is not registered with DNS on creation. This parameter is
                 only used for app creation
     * @param skipCustomDomainVerification If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
     * @param forceDnsRegistration If true, web app hostname is force registered with DNS
     * @param ttlInSeconds Time to live in seconds for web app's default domain name
     * @return the observable to the SiteInner object
     */
    public Observable<ServiceResponse<SiteInner>> beginCreateOrUpdateSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteInner siteEnvelope, Boolean skipDnsRegistration, Boolean skipCustomDomainVerification, Boolean forceDnsRegistration, String ttlInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteEnvelope == null) {
            throw new IllegalArgumentException("Parameter siteEnvelope is required and cannot be null.");
        }
        Validator.validate(siteEnvelope);
        final String apiVersion = "2016-08-01";
        return service.beginCreateOrUpdateSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteEnvelope, skipDnsRegistration, skipCustomDomainVerification, forceDnsRegistration, ttlInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteInner> clientResponse = beginCreateOrUpdateSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteInner> beginCreateOrUpdateSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteInner>() { }.getType())
                .register(202, new TypeToken<SiteInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteSlot(String resourceGroupName, String name, String slot) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean deleteMetrics = null;
        final Boolean deleteEmptyServerFarm = null;
        final Boolean skipDnsRegistration = null;
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the Object object if successful.
     */
    public Object deleteSlot(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).toBlocking().single().getBody();
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration), serviceCallback);
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSlotAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        return deleteSlotWithServiceResponseAsync(resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a web app.
     * Deletes a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deleteMetrics If true, web app metrics are also deleted
     * @param deleteEmptyServerFarm If true and App Service Plan is empty after web app deletion, App Service Plan is also deleted
     * @param skipDnsRegistration If true, DNS registration is skipped
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean deleteMetrics, Boolean deleteEmptyServerFarm, Boolean skipDnsRegistration) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), deleteMetrics, deleteEmptyServerFarm, skipDnsRegistration, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceCall.create(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String hostName = null;
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @return the CustomHostnameAnalysisResultInner object if successful.
     */
    public CustomHostnameAnalysisResultInner analyzeCustomHostnameSlot(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().getBody();
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<CustomHostnameAnalysisResultInner> serviceCallback) {
        return ServiceCall.create(analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return analyzeCustomHostnameSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<CustomHostnameAnalysisResultInner>, CustomHostnameAnalysisResultInner>() {
            @Override
            public CustomHostnameAnalysisResultInner call(ServiceResponse<CustomHostnameAnalysisResultInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Analyze a custom hostname.
     * Analyze a custom hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Custom hostname
     * @return the observable to the CustomHostnameAnalysisResultInner object
     */
    public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> analyzeCustomHostnameSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.analyzeCustomHostnameSlot(resourceGroupName, name, slot, this.client.subscriptionId(), hostName, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CustomHostnameAnalysisResultInner>>>() {
                @Override
                public Observable<ServiceResponse<CustomHostnameAnalysisResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CustomHostnameAnalysisResultInner> clientResponse = analyzeCustomHostnameSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CustomHostnameAnalysisResultInner> analyzeCustomHostnameSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CustomHostnameAnalysisResultInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<CustomHostnameAnalysisResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the Object object if successful.
     */
    public Object applySlotConfigurationSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<Object> applySlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return applySlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Applies the configuration settings from the target slot onto the current slot.
     * Applies the configuration settings from the target slot onto the current slot.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot. Settings from the target slot will be applied onto this slot
     * @param slotSwapEntity Request body that contains the target slot name. Settings from that slot will be applied on the source slot
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> applySlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.applySlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = applySlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> applySlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner backupSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> backupSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return backupSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates web app backup.
     * Creates web app backup.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> backupSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.backupSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = backupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> backupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listBackupsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listBackupsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<BackupItemInner>> * @param name Name of web app
    ServiceResponse<PageImpl<BackupItemInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listBackupsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreRequestInner object if successful.
     */
    public RestoreRequestInner discoverRestoreSlot(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request, final ServiceCallback<RestoreRequestInner> serviceCallback) {
        return ServiceCall.create(discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<RestoreRequestInner> discoverRestoreSlotAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        return discoverRestoreSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<RestoreRequestInner>, RestoreRequestInner>() {
            @Override
            public RestoreRequestInner call(ServiceResponse<RestoreRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Discovers existing web app backups that can be restored.
     * Discovers existing web app backups that can be restored.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreRequestInner object
     */
    public Observable<ServiceResponse<RestoreRequestInner>> discoverRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.discoverRestoreSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreRequestInner> clientResponse = discoverRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreRequestInner> discoverRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner getBackupStatusSlot(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> getBackupStatusSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return getBackupStatusSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress.
     * Gets status of a web app backup that may be in progress.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> getBackupStatusSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupStatusSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = getBackupStatusSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> getBackupStatusSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner deleteBackupSlot(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).toBlocking().single().getBody();
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot), serviceCallback);
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> deleteBackupSlotAsync(String resourceGroupName, String name, String backupId, String slot) {
        return deleteBackupSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a backup from Azure Storage.
     * Deletes a backup from Azure Storage.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> deleteBackupSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = deleteBackupSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> deleteBackupSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupItemInner object if successful.
     */
    public BackupItemInner listBackupStatusSecretsSlot(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().getBody();
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request, final ServiceCallback<BackupItemInner> serviceCallback) {
        return ServiceCall.create(listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<BackupItemInner> listBackupStatusSecretsSlotAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        return listBackupStatusSecretsSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<BackupItemInner>, BackupItemInner>() {
            @Override
            public BackupItemInner call(ServiceResponse<BackupItemInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     * Gets status of a web app backup that may be in progress, including secrets associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is passed in the request body.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupItemInner object
     */
    public Observable<ServiceResponse<BackupItemInner>> listBackupStatusSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.listBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupItemInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupItemInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupItemInner> clientResponse = listBackupStatusSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupItemInner> listBackupStatusSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupItemInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupItemInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner restoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().last().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<RestoreResponseInner> restoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return restoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RestoreResponseInner>> restoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.restoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RestoreResponseInner>() { }.getType());
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the RestoreResponseInner object if successful.
     */
    public RestoreResponseInner beginRestoreSlot(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).toBlocking().single().getBody();
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request, final ServiceCallback<RestoreResponseInner> serviceCallback) {
        return ServiceCall.create(beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request), serviceCallback);
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<RestoreResponseInner> beginRestoreSlotAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        return beginRestoreSlotWithServiceResponseAsync(resourceGroupName, name, backupId, slot, request).map(new Func1<ServiceResponse<RestoreResponseInner>, RestoreResponseInner>() {
            @Override
            public RestoreResponseInner call(ServiceResponse<RestoreResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restores a web app.
     * Restores a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param backupId Id of backup to restore
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on restore request
     * @return the observable to the RestoreResponseInner object
     */
    public Observable<ServiceResponse<RestoreResponseInner>> beginRestoreSlotWithServiceResponseAsync(String resourceGroupName, String name, String backupId, String slot, RestoreRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (backupId == null) {
            throw new IllegalArgumentException("Parameter backupId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.beginRestoreSlot(resourceGroupName, name, backupId, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RestoreResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RestoreResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RestoreResponseInner> clientResponse = beginRestoreSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RestoreResponseInner> beginRestoreSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RestoreResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RestoreResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateApplicationSettingsSlot(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings), serviceCallback);
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        return updateApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, appSettings).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the application settings of web app.
     * Updates the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param appSettings Application settings of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner appSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (appSettings == null) {
            throw new IllegalArgumentException("Parameter appSettings is required and cannot be null.");
        }
        Validator.validate(appSettings);
        final String apiVersion = "2016-08-01";
        return service.updateApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), appSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listApplicationSettingsSlot(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listApplicationSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listApplicationSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the application settings of web app.
     * Gets the application settings of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listApplicationSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listApplicationSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listApplicationSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listApplicationSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner updateAuthSettingsSlot(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings), serviceCallback);
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> updateAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        return updateAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteAuthSettings).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Authentication / Authorization settings associated with web app.
     * Updates the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> updateAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteAuthSettingsInner siteAuthSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteAuthSettings == null) {
            throw new IllegalArgumentException("Parameter siteAuthSettings is required and cannot be null.");
        }
        Validator.validate(siteAuthSettings);
        final String apiVersion = "2016-08-01";
        return service.updateAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteAuthSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = updateAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> updateAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteAuthSettingsInner object if successful.
     */
    public SiteAuthSettingsInner listAuthSettingsSlot(String resourceGroupName, String name, String slot) {
        return listAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteAuthSettingsInner> listAuthSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteAuthSettingsInner> serviceCallback) {
        return ServiceCall.create(listAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<SiteAuthSettingsInner> listAuthSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listAuthSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteAuthSettingsInner>, SiteAuthSettingsInner>() {
            @Override
            public SiteAuthSettingsInner call(ServiceResponse<SiteAuthSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Authentication / Authorization settings associated with web app.
     * Gets the Authentication / Authorization settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteAuthSettingsInner object
     */
    public Observable<ServiceResponse<SiteAuthSettingsInner>> listAuthSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listAuthSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteAuthSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteAuthSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteAuthSettingsInner> clientResponse = listAuthSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteAuthSettingsInner> listAuthSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteAuthSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteAuthSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner updateBackupConfigurationSlot(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).toBlocking().single().getBody();
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request), serviceCallback);
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> updateBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        return updateBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, request).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates backup configuration of web app.
     * Updates backup configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> updateBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, BackupRequestInner request) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        final String apiVersion = "2016-08-01";
        return service.updateBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), request, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = updateBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> updateBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        return deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the backup configuration for a web app.
     * Removes the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the BackupRequestInner object if successful.
     */
    public BackupRequestInner getBackupConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<BackupRequestInner> serviceCallback) {
        return ServiceCall.create(getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupRequestInner object
     */
    public Observable<BackupRequestInner> getBackupConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getBackupConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<BackupRequestInner>, BackupRequestInner>() {
            @Override
            public BackupRequestInner call(ServiceResponse<BackupRequestInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the backup configuration for a web app.
     * Gets the backup configuration for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the BackupRequestInner object
     */
    public Observable<ServiceResponse<BackupRequestInner>> getBackupConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getBackupConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BackupRequestInner>>>() {
                @Override
                public Observable<ServiceResponse<BackupRequestInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BackupRequestInner> clientResponse = getBackupConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BackupRequestInner> getBackupConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupRequestInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BackupRequestInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner updateConnectionStringsSlot(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).toBlocking().single().getBody();
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings), serviceCallback);
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> updateConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        return updateConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot, connectionStrings).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the connection strings associated with web app.
     * Updates the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param connectionStrings Connection strings associated with web app
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> updateConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, ConnectionStringDictionaryInner connectionStrings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionStrings == null) {
            throw new IllegalArgumentException("Parameter connectionStrings is required and cannot be null.");
        }
        Validator.validate(connectionStrings);
        final String apiVersion = "2016-08-01";
        return service.updateConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), connectionStrings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = updateConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> updateConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the ConnectionStringDictionaryInner object if successful.
     */
    public ConnectionStringDictionaryInner listConnectionStringsSlot(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<ConnectionStringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ConnectionStringDictionaryInner> listConnectionStringsSlotAsync(String resourceGroupName, String name, String slot) {
        return listConnectionStringsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<ConnectionStringDictionaryInner>, ConnectionStringDictionaryInner>() {
            @Override
            public ConnectionStringDictionaryInner call(ServiceResponse<ConnectionStringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the connection strings associated with web app.
     * Gets the connection strings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the ConnectionStringDictionaryInner object
     */
    public Observable<ServiceResponse<ConnectionStringDictionaryInner>> listConnectionStringsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listConnectionStringsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ConnectionStringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ConnectionStringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ConnectionStringDictionaryInner> clientResponse = listConnectionStringsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ConnectionStringDictionaryInner> listConnectionStringsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ConnectionStringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ConnectionStringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner getDiagnosticLogsConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app logs configuration.
     * Gets the web app logs configuration.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> getDiagnosticLogsConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = getDiagnosticLogsConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> getDiagnosticLogsConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the SiteLogsConfigInner object if successful.
     */
    public SiteLogsConfigInner updateDiagnosticLogsConfigSlot(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig, final ServiceCallback<SiteLogsConfigInner> serviceCallback) {
        return ServiceCall.create(updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        return updateDiagnosticLogsConfigSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteLogsConfig).map(new Func1<ServiceResponse<SiteLogsConfigInner>, SiteLogsConfigInner>() {
            @Override
            public SiteLogsConfigInner call(ServiceResponse<SiteLogsConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteLogsConfig Site logs configuration
     * @return the observable to the SiteLogsConfigInner object
     */
    public Observable<ServiceResponse<SiteLogsConfigInner>> updateDiagnosticLogsConfigSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteLogsConfigInner siteLogsConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteLogsConfig == null) {
            throw new IllegalArgumentException("Parameter siteLogsConfig is required and cannot be null.");
        }
        Validator.validate(siteLogsConfig);
        final String apiVersion = "2016-08-01";
        return service.updateDiagnosticLogsConfigSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteLogsConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteLogsConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteLogsConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteLogsConfigInner> clientResponse = updateDiagnosticLogsConfigSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteLogsConfigInner> updateDiagnosticLogsConfigSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteLogsConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteLogsConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner updateMetadataSlot(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).toBlocking().single().getBody();
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata), serviceCallback);
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> updateMetadataSlotAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        return updateMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot, metadata).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the meta data for web app.
     * Updates the meta data for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param metadata Meta data of web app
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> updateMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, StringDictionaryInner metadata) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (metadata == null) {
            throw new IllegalArgumentException("Parameter metadata is required and cannot be null.");
        }
        Validator.validate(metadata);
        final String apiVersion = "2016-08-01";
        return service.updateMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), metadata, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = updateMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> updateMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the StringDictionaryInner object if successful.
     */
    public StringDictionaryInner listMetadataSlot(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<StringDictionaryInner> serviceCallback) {
        return ServiceCall.create(listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<StringDictionaryInner> listMetadataSlotAsync(String resourceGroupName, String name, String slot) {
        return listMetadataSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<StringDictionaryInner>, StringDictionaryInner>() {
            @Override
            public StringDictionaryInner call(ServiceResponse<StringDictionaryInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app meta data.
     * Gets the web app meta data.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the StringDictionaryInner object
     */
    public Observable<ServiceResponse<StringDictionaryInner>> listMetadataSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetadataSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringDictionaryInner>>>() {
                @Override
                public Observable<ServiceResponse<StringDictionaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringDictionaryInner> clientResponse = listMetadataSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringDictionaryInner> listMetadataSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<StringDictionaryInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringDictionaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the UserInner object if successful.
     */
    public UserInner listPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().last().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable for the request
     */
    public Observable<UserInner> listPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<UserInner>> listPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.listPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<UserInner>() { }.getType());
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the UserInner object if successful.
     */
    public UserInner beginListPublishingCredentialsSlot(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<UserInner> serviceCallback) {
        return ServiceCall.create(beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the UserInner object
     */
    public Observable<UserInner> beginListPublishingCredentialsSlotAsync(String resourceGroupName, String name, String slot) {
        return beginListPublishingCredentialsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<UserInner>, UserInner>() {
            @Override
            public UserInner call(ServiceResponse<UserInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the web app publishing credentials.
     * Gets the web app publishing credentials.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the UserInner object
     */
    public Observable<ServiceResponse<UserInner>> beginListPublishingCredentialsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserInner>>>() {
                @Override
                public Observable<ServiceResponse<UserInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserInner> clientResponse = beginListPublishingCredentialsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserInner> beginListPublishingCredentialsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<UserInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<UserInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner updateSitePushSettingsSlot(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).toBlocking().single().getBody();
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceCall.create(updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings), serviceCallback);
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> updateSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        return updateSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot, pushSettings).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Push settings associated with web app.
     * Updates the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> updateSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, PushSettingsInner pushSettings) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (pushSettings == null) {
            throw new IllegalArgumentException("Parameter pushSettings is required and cannot be null.");
        }
        Validator.validate(pushSettings);
        final String apiVersion = "2016-08-01";
        return service.updateSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), pushSettings, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = updateSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> updateSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PushSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PushSettingsInner object if successful.
     */
    public PushSettingsInner listSitePushSettingsSlot(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<PushSettingsInner> serviceCallback) {
        return ServiceCall.create(listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PushSettingsInner object
     */
    public Observable<PushSettingsInner> listSitePushSettingsSlotAsync(String resourceGroupName, String name, String slot) {
        return listSitePushSettingsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<PushSettingsInner>, PushSettingsInner>() {
            @Override
            public PushSettingsInner call(ServiceResponse<PushSettingsInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the Push settings associated with web app.
     * Gets the Push settings associated with web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PushSettingsInner object
     */
    public Observable<ServiceResponse<PushSettingsInner>> listSitePushSettingsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSitePushSettingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PushSettingsInner>>>() {
                @Override
                public Observable<ServiceResponse<PushSettingsInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PushSettingsInner> clientResponse = listSitePushSettingsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PushSettingsInner> listSitePushSettingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PushSettingsInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PushSettingsInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner getConfigurationSlot(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> getConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return getConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the configuration of the web app.
     * Gets the configuration of the web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> getConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = getConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> getConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner createOrUpdateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> createOrUpdateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return createOrUpdateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> createOrUpdateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = createOrUpdateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> createOrUpdateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the SiteConfigInner object if successful.
     */
    public SiteConfigInner updateConfigurationSlot(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).toBlocking().single().getBody();
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteConfigInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig, final ServiceCallback<SiteConfigInner> serviceCallback) {
        return ServiceCall.create(updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig), serviceCallback);
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<SiteConfigInner> updateConfigurationSlotAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        return updateConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteConfig).map(new Func1<ServiceResponse<SiteConfigInner>, SiteConfigInner>() {
            @Override
            public SiteConfigInner call(ServiceResponse<SiteConfigInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the configuration of web app.
     * Update the configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteConfig Request body that contains the configuraiton setting for the web app
     * @return the observable to the SiteConfigInner object
     */
    public Observable<ServiceResponse<SiteConfigInner>> updateConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteConfigInner siteConfig) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteConfig == null) {
            throw new IllegalArgumentException("Parameter siteConfig is required and cannot be null.");
        }
        Validator.validate(siteConfig);
        final String apiVersion = "2016-08-01";
        return service.updateConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteConfig, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteConfigInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteConfigInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteConfigInner> clientResponse = updateConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteConfigInner> updateConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteConfigInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteConfigInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listDeploymentsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return getDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createDeploymentSlot(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        return createDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteDeploymentSlot(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot), serviceCallback);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot) {
        return deleteDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteDeploymentSlot(resourceGroupName, name, id, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listHostNameBindingsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param name Name of web app
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHostNameBindingsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner getHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().getBody();
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> getHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return getHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get web app binding for a hostname.
     * Get web app binding for a hostname.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> getHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = getHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> getHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the HostNameBindingInner object if successful.
     */
    public HostNameBindingInner createOrUpdateHostNameBindingSlot(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).toBlocking().single().getBody();
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding, final ServiceCallback<HostNameBindingInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding), serviceCallback);
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<HostNameBindingInner> createOrUpdateHostNameBindingSlotAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        return createOrUpdateHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, hostName, slot, hostNameBinding).map(new Func1<ServiceResponse<HostNameBindingInner>, HostNameBindingInner>() {
            @Override
            public HostNameBindingInner call(ServiceResponse<HostNameBindingInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a web app hostname binding.
     * Creates a web app hostname binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param hostName Name of host
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostNameBinding Host name binding information
     * @return the observable to the HostNameBindingInner object
     */
    public Observable<ServiceResponse<HostNameBindingInner>> createOrUpdateHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String hostName, String slot, HostNameBindingInner hostNameBinding) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (hostNameBinding == null) {
            throw new IllegalArgumentException("Parameter hostNameBinding is required and cannot be null.");
        }
        Validator.validate(hostNameBinding);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, slot, this.client.subscriptionId(), hostNameBinding, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HostNameBindingInner>>>() {
                @Override
                public Observable<ServiceResponse<HostNameBindingInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HostNameBindingInner> clientResponse = createOrUpdateHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HostNameBindingInner> createOrUpdateHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HostNameBindingInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HostNameBindingInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the Object object if successful.
     */
    public Object deleteHostNameBindingSlot(String resourceGroupName, String name, String slot, String hostName) {
        return deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).toBlocking().single().getBody();
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName), serviceCallback);
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<Object> deleteHostNameBindingSlotAsync(String resourceGroupName, String name, String slot, String hostName) {
        return deleteHostNameBindingSlotWithServiceResponseAsync(resourceGroupName, name, slot, hostName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Deletes a host name binding.
     * Deletes a host name binding.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param hostName Name of host
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteHostNameBindingSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String hostName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (hostName == null) {
            throw new IllegalArgumentException("Parameter hostName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteHostNameBindingSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteHostNameBindingSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner getHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> getHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return getHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> getHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = getHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> getHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner createOrUpdateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> createOrUpdateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return createOrUpdateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> createOrUpdateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = createOrUpdateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> createOrUpdateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the Object object if successful.
     */
    public Object deleteHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().getBody();
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return deleteHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes a Hybrid Connection from this site.
     * Removes a Hybrid Connection from this site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner updateHybridConnectionSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> updateHybridConnectionSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        return updateHybridConnectionSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new Hybrid Connection using a Service Bus relay.
     * Creates a new Hybrid Connection using a Service Bus relay.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> updateHybridConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, HybridConnectionInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = updateHybridConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> updateHybridConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the Object object if successful.
     */
    public Object listHybridConnectionKeysSlot(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot), serviceCallback);
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<Object> listHybridConnectionKeysSlotAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        return listHybridConnectionKeysSlotWithServiceResponseAsync(resourceGroupName, name, namespaceName, relayName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the send key name and value for a Hybrid Connection.
     * Gets the send key name and value for a Hybrid Connection.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param namespaceName The namespace for this hybrid connection
     * @param relayName The relay name for this hybrid connection
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listHybridConnectionKeysSlotWithServiceResponseAsync(String resourceGroupName, String name, String namespaceName, String relayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (namespaceName == null) {
            throw new IllegalArgumentException("Parameter namespaceName is required and cannot be null.");
        }
        if (relayName == null) {
            throw new IllegalArgumentException("Parameter relayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionKeysSlot(resourceGroupName, name, namespaceName, relayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listHybridConnectionKeysSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listHybridConnectionKeysSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the HybridConnectionInner object if successful.
     */
    public HybridConnectionInner listHybridConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<HybridConnectionInner> serviceCallback) {
        return ServiceCall.create(listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<HybridConnectionInner> listHybridConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listHybridConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<HybridConnectionInner>, HybridConnectionInner>() {
            @Override
            public HybridConnectionInner call(ServiceResponse<HybridConnectionInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     * Retrieves all Service Bus Hybrid Connections used by this Web App.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the HybridConnectionInner object
     */
    public Observable<ServiceResponse<HybridConnectionInner>> listHybridConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listHybridConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<HybridConnectionInner>>>() {
                @Override
                public Observable<ServiceResponse<HybridConnectionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<HybridConnectionInner> clientResponse = listHybridConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<HybridConnectionInner> listHybridConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<HybridConnectionInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<HybridConnectionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner listRelayServiceConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listRelayServiceConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     * Retrieves all Biztalk Hybrid Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> listRelayServiceConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listRelayServiceConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = listRelayServiceConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> listRelayServiceConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner getRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return getRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     * Retrieves a Biztalk Hybrid Connection identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> getRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = getRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> getRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner createOrUpdateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> createOrUpdateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = createOrUpdateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> createOrUpdateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the Object object if successful.
     */
    public Object deleteRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot) {
        return deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).toBlocking().single().getBody();
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot), serviceCallback);
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot) {
        return deleteRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     * Removes the association to a Biztalk Hybrid Connection, identified by its entity name.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the RelayServiceConnectionEntityInner object if successful.
     */
    public RelayServiceConnectionEntityInner updateRelayServiceConnectionSlot(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope, final ServiceCallback<RelayServiceConnectionEntityInner> serviceCallback) {
        return ServiceCall.create(updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        return updateRelayServiceConnectionSlotWithServiceResponseAsync(resourceGroupName, name, entityName, slot, connectionEnvelope).map(new Func1<ServiceResponse<RelayServiceConnectionEntityInner>, RelayServiceConnectionEntityInner>() {
            @Override
            public RelayServiceConnectionEntityInner call(ServiceResponse<RelayServiceConnectionEntityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     * Creates a new association to a Biztalk Hybrid Connection, or updates an existing one.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param entityName The name by which the Hybrid Connection is identified
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the Hybrid Connection
     * @return the observable to the RelayServiceConnectionEntityInner object
     */
    public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> updateRelayServiceConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String entityName, String slot, RelayServiceConnectionEntityInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RelayServiceConnectionEntityInner>>>() {
                @Override
                public Observable<ServiceResponse<RelayServiceConnectionEntityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RelayServiceConnectionEntityInner> clientResponse = updateRelayServiceConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RelayServiceConnectionEntityInner> updateRelayServiceConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RelayServiceConnectionEntityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RelayServiceConnectionEntityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listInstanceIdentifiersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceIdentifiersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsSlot(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsSlotAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceDeploymentsSlotWithServiceResponseAsync(resourceGroupName, name, slot, instanceId)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        return listInstanceDeploymentsSlotSinglePageAsync(resourceGroupName, name, slot, instanceId)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<DeploymentInner>> * @param name Name of web app
    ServiceResponse<PageImpl<DeploymentInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<DeploymentInner>> * @param instanceId Id of web app instance
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listInstanceDeploymentsSlot(resourceGroupName, name, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner getInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().getBody();
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> getInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return getInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the deployment.
     * Get the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> getInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = getInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> getInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the DeploymentInner object if successful.
     */
    public DeploymentInner createInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).toBlocking().single().getBody();
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment, final ServiceCallback<DeploymentInner> serviceCallback) {
        return ServiceCall.create(createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment), serviceCallback);
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<DeploymentInner> createInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        return createInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId, deployment).map(new Func1<ServiceResponse<DeploymentInner>, DeploymentInner>() {
            @Override
            public DeploymentInner call(ServiceResponse<DeploymentInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Create a deployment.
     * Create a deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param deployment Details of deployment
     * @return the observable to the DeploymentInner object
     */
    public Observable<ServiceResponse<DeploymentInner>> createInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId, DeploymentInner deployment) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (deployment == null) {
            throw new IllegalArgumentException("Parameter deployment is required and cannot be null.");
        }
        Validator.validate(deployment);
        final String apiVersion = "2016-08-01";
        return service.createInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), deployment, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DeploymentInner>>>() {
                @Override
                public Observable<ServiceResponse<DeploymentInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DeploymentInner> clientResponse = createInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DeploymentInner> createInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<DeploymentInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DeploymentInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the Object object if successful.
     */
    public Object deleteInstanceDeploymentSlot(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).toBlocking().single().getBody();
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId), serviceCallback);
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<Object> deleteInstanceDeploymentSlotAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        return deleteInstanceDeploymentSlotWithServiceResponseAsync(resourceGroupName, name, id, slot, instanceId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete the deployment.
     * Delete the deployment.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param id Id of the deployment
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId Id of web app instance
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteInstanceDeploymentSlotWithServiceResponseAsync(String resourceGroupName, String name, String id, String slot, String instanceId) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteInstanceDeploymentSlot(resourceGroupName, name, id, slot, instanceId, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteInstanceDeploymentSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteInstanceDeploymentSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteCloneabilityInner object if successful.
     */
    public SiteCloneabilityInner isCloneableSlot(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteCloneabilityInner> serviceCallback) {
        return ServiceCall.create(isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<SiteCloneabilityInner> isCloneableSlotAsync(String resourceGroupName, String name, String slot) {
        return isCloneableSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteCloneabilityInner>, SiteCloneabilityInner>() {
            @Override
            public SiteCloneabilityInner call(ServiceResponse<SiteCloneabilityInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Creates a new web app or modifies an existing web app.
     * Creates a new web app or modifies an existing web app.
     *
     * @param resourceGroupName Name of the resource group
     * @param name Name of the web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteCloneabilityInner object
     */
    public Observable<ServiceResponse<SiteCloneabilityInner>> isCloneableSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.isCloneableSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteCloneabilityInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteCloneabilityInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteCloneabilityInner> clientResponse = isCloneableSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteCloneabilityInner> isCloneableSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteCloneabilityInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteCloneabilityInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefinitionsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefinitionsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricDefinitionsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param name Name of web app
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricDefinitionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefinitionsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefinitionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean details = null;
        final String filter = null;
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlot(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotWithServiceResponseAsync(resourceGroupName, name, slot, details, filter)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param details If true, metric details are included in response
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        return listMetricsSlotSinglePageAsync(resourceGroupName, name, slot, details, filter)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param name Name of web app
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param details If true, metric details are included in response
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final Boolean details, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listMetricsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), details, filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the NetworkFeaturesInner object if successful.
     */
    public NetworkFeaturesInner listNetworkFeaturesSlot(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot, final ServiceCallback<NetworkFeaturesInner> serviceCallback) {
        return ServiceCall.create(listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot), serviceCallback);
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<NetworkFeaturesInner> listNetworkFeaturesSlotAsync(String resourceGroupName, String name, String view, String slot) {
        return listNetworkFeaturesSlotWithServiceResponseAsync(resourceGroupName, name, view, slot).map(new Func1<ServiceResponse<NetworkFeaturesInner>, NetworkFeaturesInner>() {
            @Override
            public NetworkFeaturesInner call(ServiceResponse<NetworkFeaturesInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a view of all network features in use on this web app.
     * Retrieves a view of all network features in use on this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param view The type of view. This can either be "summary" or "detailed".
     * @param slot The name of the slot for this web app.
     * @return the observable to the NetworkFeaturesInner object
     */
    public Observable<ServiceResponse<NetworkFeaturesInner>> listNetworkFeaturesSlotWithServiceResponseAsync(String resourceGroupName, String name, String view, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (view == null) {
            throw new IllegalArgumentException("Parameter view is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listNetworkFeaturesSlot(resourceGroupName, name, view, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NetworkFeaturesInner>>>() {
                @Override
                public Observable<ServiceResponse<NetworkFeaturesInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NetworkFeaturesInner> clientResponse = listNetworkFeaturesSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<NetworkFeaturesInner> listNetworkFeaturesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<NetworkFeaturesInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<NetworkFeaturesInner>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Integer durationInSeconds = null;
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the String object if successful.
     */
    public String startWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot, Integer durationInSeconds) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds).toBlocking().single().getBody();
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds), serviceCallback);
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the observable to the String object
     */
    public Observable<String> startWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds) {
        return startWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot, durationInSeconds).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Start capturing network packets for the site.
     * Start capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param durationInSeconds The duration to keep capturing in seconds
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> startWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Integer durationInSeconds) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), durationInSeconds, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = startWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> startWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<String, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the String object if successful.
     */
    public String stopWebSiteNetworkTraceSlot(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<String> serviceCallback) {
        return ServiceCall.create(stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the String object
     */
    public Observable<String> stopWebSiteNetworkTraceSlotAsync(String resourceGroupName, String name, String slot) {
        return stopWebSiteNetworkTraceSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<String>, String>() {
            @Override
            public String call(ServiceResponse<String> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stop ongoing capturing network packets for the site.
     * Stop ongoing capturing network packets for the site.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the String object
     */
    public Observable<ServiceResponse<String>> stopWebSiteNetworkTraceSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<String>>>() {
                @Override
                public Observable<ServiceResponse<String>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<String> clientResponse = stopWebSiteNetworkTraceSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<String> stopWebSiteNetworkTraceSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<String, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<String>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object generateNewSitePublishingPasswordSlot(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> generateNewSitePublishingPasswordSlotAsync(String resourceGroupName, String name, String slot) {
        return generateNewSitePublishingPasswordSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Generates new random app publishing password.
     * Generates new random app publishing password.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> generateNewSitePublishingPasswordSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = generateNewSitePublishingPasswordSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> generateNewSitePublishingPasswordSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object getOperationSlot(String resourceGroupName, String name, String operationId, String slot) {
        return getOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot), serviceCallback);
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> getOperationSlotAsync(String resourceGroupName, String name, String operationId, String slot) {
        return getOperationSlotWithServiceResponseAsync(resourceGroupName, name, operationId, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the operation for a web app.
     * Gets the operation for a web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param operationId Id of an operation
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getOperationSlotWithServiceResponseAsync(String resourceGroupName, String name, String operationId, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getOperationSlot(resourceGroupName, name, operationId, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getOperationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getOperationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
     * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listPerfMonCountersSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param name Name of web app
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param slot Name of web app slot. If not specified then will default to production slot. **** CURRENTLY UNUSED *****
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param filter Return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example: $filter=(startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPerfMonCountersSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<PerfMonResponseInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the List&lt;Object&gt; object if successful.
     */
    public List<Object> getSitePhpErrorLogFlagSlot(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<Object>> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<Object>> serviceCallback) {
        return ServiceCall.create(getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;Object&gt; object
     */
    public Observable<List<Object>> getSitePhpErrorLogFlagSlotAsync(String resourceGroupName, String name, String slot) {
        return getSitePhpErrorLogFlagSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<Object>>, List<Object>>() {
            @Override
            public List<Object> call(ServiceResponse<List<Object>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets sites's event logs.
     * Gets sites's event logs.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the List&lt;Object&gt; object
     */
    public Observable<ServiceResponse<List<Object>>> getSitePhpErrorLogFlagSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Object>>>>() {
                @Override
                public Observable<ServiceResponse<List<Object>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Object>> clientResponse = getSitePhpErrorLogFlagSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Object>> getSitePhpErrorLogFlagSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<Object>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Object>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param slot web app slot name
     * @return the Object object if successful.
     */
    public Object listPremierAddOnsSlot(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param slot web app slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<Object> listPremierAddOnsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPremierAddOnsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * List premier add ons for web app.
     * List premier add ons for web app.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listPremierAddOnsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listPremierAddOnsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listPremierAddOnsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listPremierAddOnsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the Object object if successful.
     */
    public Object getPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().getBody();
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<Object> getPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return getPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets a specific premier add on.
     * Gets a specific premier add on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param premierAddOn Premier add on request
     * @return the Object object if successful.
     */
    public Object addPremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).toBlocking().single().getBody();
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param premierAddOn Premier add on request
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn), serviceCallback);
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param premierAddOn Premier add on request
     * @return the observable to the Object object
     */
    public Observable<Object> addPremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        return addPremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot, premierAddOn).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Add premier add-on.
     * Add premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param premierAddOn Premier add on request
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> addPremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot, PremierAddOnRequestInner premierAddOn) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (premierAddOn == null) {
            throw new IllegalArgumentException("Parameter premierAddOn is required and cannot be null.");
        }
        Validator.validate(premierAddOn);
        final String apiVersion = "2016-08-01";
        return service.addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), premierAddOn, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = addPremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> addPremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the Object object if successful.
     */
    public Object deletePremierAddOnSlot(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).toBlocking().single().getBody();
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot), serviceCallback);
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<Object> deletePremierAddOnSlotAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        return deletePremierAddOnSlotWithServiceResponseAsync(resourceGroupName, name, premierAddOnName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete premier add-on.
     * Delete premier add-on.
     *
     * @param resourceGroupName Resource group
     * @param name web app name
     * @param premierAddOnName Premier add on
     * @param slot web app slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deletePremierAddOnSlotWithServiceResponseAsync(String resourceGroupName, String name, String premierAddOnName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (premierAddOnName == null) {
            throw new IllegalArgumentException("Parameter premierAddOnName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deletePremierAddOnSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deletePremierAddOnSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String format = null;
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(null);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the InputStream object if successful.
     */
    public InputStream listPublishingProfileXmlWithSecretsSlot(String resourceGroupName, String name, String slot, String format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).toBlocking().single().getBody();
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, String format, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceCall.create(listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format), serviceCallback);
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> listPublishingProfileXmlWithSecretsSlotAsync(String resourceGroupName, String name, String slot, String format) {
        return listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(resourceGroupName, name, slot, format).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Gets the publishing profile for web app.
     * Gets the publishing profile for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param format Name of the format. Valid values are: 
                 FileZilla3
                 WebDeploy -- default
                 Ftp
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> listPublishingProfileXmlWithSecretsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, String format) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        CsmPublishingProfileOptions options = new CsmPublishingProfileOptions();
        options.withFormat(format);
        return service.listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), options, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = listPublishingProfileXmlWithSecretsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> listPublishingProfileXmlWithSecretsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<InputStream, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner recoverSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().last().getBody();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RecoverResponseInner> recoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceCall.create(recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<RecoverResponseInner> recoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return recoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable for the request
     */
    public Observable<ServiceResponse<RecoverResponseInner>> recoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.recoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<RecoverResponseInner>() { }.getType());
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the RecoverResponseInner object if successful.
     */
    public RecoverResponseInner beginRecoverSlot(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).toBlocking().single().getBody();
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<RecoverResponseInner> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity, final ServiceCallback<RecoverResponseInner> serviceCallback) {
        return ServiceCall.create(beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity), serviceCallback);
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<RecoverResponseInner> beginRecoverSlotAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        return beginRecoverSlotWithServiceResponseAsync(resourceGroupName, name, slot, recoveryEntity).map(new Func1<ServiceResponse<RecoverResponseInner>, RecoverResponseInner>() {
            @Override
            public RecoverResponseInner call(ServiceResponse<RecoverResponseInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Recovers a deleted web app.
     * Recovers a deleted web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param recoveryEntity Snapshot data used for web app recovery. Snapshot information can be obtained by calling GetDeletedSites or GetSiteSnapshots API.
     * @return the observable to the RecoverResponseInner object
     */
    public Observable<ServiceResponse<RecoverResponseInner>> beginRecoverSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSiteRecoveryEntityInner recoveryEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (recoveryEntity == null) {
            throw new IllegalArgumentException("Parameter recoveryEntity is required and cannot be null.");
        }
        Validator.validate(recoveryEntity);
        final String apiVersion = "2016-08-01";
        return service.beginRecoverSlot(resourceGroupName, name, slot, this.client.subscriptionId(), recoveryEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RecoverResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<RecoverResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RecoverResponseInner> clientResponse = beginRecoverSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RecoverResponseInner> beginRecoverSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<RecoverResponseInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<RecoverResponseInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object resetSlotConfigurationSlot(String resourceGroupName, String name, String slot) {
        return resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> resetSlotConfigurationSlotAsync(String resourceGroupName, String name, String slot) {
        return resetSlotConfigurationSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     * Resets the configuration settings of the current slot if they were previously modified by calling ApplySlotConfig API.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resetSlotConfigurationSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.resetSlotConfigurationSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resetSlotConfigurationSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resetSlotConfigurationSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object restartSlot(String resourceGroupName, String name, String slot) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> restartSlotAsync(String resourceGroupName, String name, String slot) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final Boolean softRestart = null;
        final Boolean synchronous = null;
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the Object object if successful.
     */
    public Object restartSlot(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).toBlocking().single().getBody();
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous), serviceCallback);
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<Object> restartSlotAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        return restartSlotWithServiceResponseAsync(resourceGroupName, name, slot, softRestart, synchronous).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Restarts web app.
     * Restarts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param softRestart Soft restart applies the configuration settings and restarts the app if necessary. Hard restart always restarts and reprovisions the app
     * @param synchronous If true then the API will block until the app has been restarted
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> restartSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, Boolean softRestart, Boolean synchronous) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.restartSlot(resourceGroupName, name, slot, this.client.subscriptionId(), softRestart, synchronous, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = restartSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> restartSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesSlot(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesSlotAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of the source slot
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesSlotSinglePageAsync(resourceGroupName, name, slot, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slot Name of the source slot
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.getSlotsDifferencesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object swapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().last().getBody();
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<Object> swapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.swapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object beginSwapSlotsSlot(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<Object> beginSwapSlotsSlotAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotsSlotWithServiceResponseAsync(resourceGroupName, name, slot, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of source slot for the swap
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.beginSwapSlotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @param slot Website Slot
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<SnapshotInner>(response.getBody()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @param slot Website Slot
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceCall.create(
            listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @param slot Website Slot
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @param slot Website Slot
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listSnapshotsSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Resource group
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name
    ServiceResponse<PageImpl<SnapshotInner>> * @param slot Website Slot
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSnapshotsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SnapshotInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControlSlot(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return getSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object deleteSourceControlSlot(String resourceGroupName, String name, String slot) {
        return deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSourceControlSlotAsync(String resourceGroupName, String name, String slot) {
        return deleteSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSourceControlSlot(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSourceControlSlotAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlSlotWithServiceResponseAsync(resourceGroupName, name, slot, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSourceControlSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.updateSourceControlSlot(resourceGroupName, name, slot, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSourceControlSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSourceControlSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object startSlot(String resourceGroupName, String name, String slot) {
        return startSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> startSlotAsync(String resourceGroupName, String name, String slot) {
        return startSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.startSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object stopSlot(String resourceGroupName, String name, String slot) {
        return stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> stopSlotAsync(String resourceGroupName, String name, String slot) {
        return stopSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stopSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the Object object if successful.
     */
    public Object syncRepositorySlot(String resourceGroupName, String name, String slot) {
        return syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncRepositorySlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<Object> syncRepositorySlotAsync(String resourceGroupName, String name, String slot) {
        return syncRepositorySlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncRepositorySlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.syncRepositorySlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncRepositorySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncRepositorySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlot(final String resourceGroupName, final String name, final String slot, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotWithServiceResponseAsync(resourceGroupName, name, slot, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotWithServiceResponseAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        return listUsagesSlotSinglePageAsync(resourceGroupName, name, slot, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param slot Name of web app slot. If not specified then will default to production slot.
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotSinglePageAsync(final String resourceGroupName, final String name, final String slot, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listUsagesSlot(resourceGroupName, name, slot, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnectionsSlot(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsSlotAsync(String resourceGroupName, String name, String slot) {
        return listVnetConnectionsSlotWithServiceResponseAsync(resourceGroupName, name, slot).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param slot The name of the slot for this web app.
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listVnetConnectionsSlot(resourceGroupName, name, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return getVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the Object object if successful.
     */
    public Object deleteVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).toBlocking().single().getBody();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<Object> deleteVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot) {
        return deleteVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnectionSlot(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionSlotAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionSlotWithServiceResponseAsync(resourceGroupName, name, vnetName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionSlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String slot, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionSlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the Object object if successful.
     */
    public Object getVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<Object> getVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        return getVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGatewaySlot(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewaySlotAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewaySlotWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param slot The name of the slot for this web app.
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewaySlotWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, String slot, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (slot == null) {
            throw new IllegalArgumentException("Parameter slot is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewaySlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewaySlotDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesFromProduction(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesFromProductionAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesFromProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionWithServiceResponseAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        return getSlotsDifferencesFromProductionSinglePageAsync(resourceGroupName, name, slotSwapEntity)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param name Name of web app
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param slotSwapEntity Request body that contains the target slot name
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionSinglePageAsync(final String resourceGroupName, final String name, final CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.getSlotsDifferencesFromProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object swapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().last().getBody();
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<Object> swapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return swapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable for the request
     */
    public Observable<ServiceResponse<Object>> swapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        Observable<Response<ResponseBody>> observable = service.swapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<Object>() { }.getType());
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the Object object if successful.
     */
    public Object beginSwapSlotWithProduction(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).toBlocking().single().getBody();
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity), serviceCallback);
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<Object> beginSwapSlotWithProductionAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        return beginSwapSlotWithProductionWithServiceResponseAsync(resourceGroupName, name, slotSwapEntity).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Swaps web app slots.
     * Swaps web app slots.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param slotSwapEntity Request body that contains the target slot name
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> beginSwapSlotWithProductionWithServiceResponseAsync(String resourceGroupName, String name, CsmSlotEntityInner slotSwapEntity) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (slotSwapEntity == null) {
            throw new IllegalArgumentException("Parameter slotSwapEntity is required and cannot be null.");
        }
        Validator.validate(slotSwapEntity);
        final String apiVersion = "2016-08-01";
        return service.beginSwapSlotWithProduction(resourceGroupName, name, this.client.subscriptionId(), slotSwapEntity, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = beginSwapSlotWithProductionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> beginSwapSlotWithProductionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(202, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshots(final String resourceGroupName, final String name) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<SnapshotInner>(response.getBody()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceCall.create(
            listSnapshotsSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsAsync(final String resourceGroupName, final String name) {
        return listSnapshotsWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param resourceGroupName Resource group
     * @param name Website Name
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listSnapshotsSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param resourceGroupName Resource group
    ServiceResponse<PageImpl<SnapshotInner>> * @param name Website Name
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listSnapshots(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SnapshotInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner getSourceControl(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(getSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> getSourceControlAsync(String resourceGroupName, String name) {
        return getSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Get the source control configuration of web app.
     * Get the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> getSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getSourceControl(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = getSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> getSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner createOrUpdateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> createOrUpdateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return createOrUpdateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> createOrUpdateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = createOrUpdateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> createOrUpdateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object deleteSourceControl(String resourceGroupName, String name) {
        return deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteSourceControlAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteSourceControlWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSourceControlAsync(String resourceGroupName, String name) {
        return deleteSourceControlWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Delete source control configuration of web app.
     * Delete source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteSourceControlWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteSourceControl(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the SiteSourceControlInner object if successful.
     */
    public SiteSourceControlInner updateSourceControl(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).toBlocking().single().getBody();
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<SiteSourceControlInner> updateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl, final ServiceCallback<SiteSourceControlInner> serviceCallback) {
        return ServiceCall.create(updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl), serviceCallback);
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<SiteSourceControlInner> updateSourceControlAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        return updateSourceControlWithServiceResponseAsync(resourceGroupName, name, siteSourceControl).map(new Func1<ServiceResponse<SiteSourceControlInner>, SiteSourceControlInner>() {
            @Override
            public SiteSourceControlInner call(ServiceResponse<SiteSourceControlInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Update the source control configuration of web app.
     * Update the source control configuration of web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param siteSourceControl Request body that contains the source control parameters
     * @return the observable to the SiteSourceControlInner object
     */
    public Observable<ServiceResponse<SiteSourceControlInner>> updateSourceControlWithServiceResponseAsync(String resourceGroupName, String name, SiteSourceControlInner siteSourceControl) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (siteSourceControl == null) {
            throw new IllegalArgumentException("Parameter siteSourceControl is required and cannot be null.");
        }
        Validator.validate(siteSourceControl);
        final String apiVersion = "2016-08-01";
        return service.updateSourceControl(resourceGroupName, name, this.client.subscriptionId(), siteSourceControl, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SiteSourceControlInner>>>() {
                @Override
                public Observable<ServiceResponse<SiteSourceControlInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SiteSourceControlInner> clientResponse = updateSourceControlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SiteSourceControlInner> updateSourceControlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SiteSourceControlInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<SiteSourceControlInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object start(String resourceGroupName, String name) {
        return startWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> startAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(startWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> startAsync(String resourceGroupName, String name) {
        return startWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Starts web app.
     * Starts web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> startWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.start(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = startDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> startDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object stop(String resourceGroupName, String name) {
        return stopWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> stopAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(stopWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> stopAsync(String resourceGroupName, String name) {
        return stopWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Stops web app.
     * Stops web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> stopWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.stop(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = stopDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> stopDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the Object object if successful.
     */
    public Object syncRepository(String resourceGroupName, String name) {
        return syncRepositoryWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> syncRepositoryAsync(String resourceGroupName, String name, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(syncRepositoryWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<Object> syncRepositoryAsync(String resourceGroupName, String name) {
        return syncRepositoryWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Sync web app repository.
     * Sync web app repository.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> syncRepositoryWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.syncRepository(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = syncRepositoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> syncRepositoryDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesSinglePageAsync(resourceGroupName, name),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name) {
        return listUsagesSinglePageAsync(resourceGroupName, name)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        final String filter = null;
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsages(final String resourceGroupName, final String name, final String filter) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSinglePageAsync(resourceGroupName, name, filter).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesSinglePageAsync(resourceGroupName, name, filter),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesWithServiceResponseAsync(resourceGroupName, name, filter)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param resourceGroupName Name of resource group
     * @param name Name of web app
     * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesWithServiceResponseAsync(final String resourceGroupName, final String name, final String filter) {
        return listUsagesSinglePageAsync(resourceGroupName, name, filter)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param resourceGroupName Name of resource group
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param name Name of web app
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param filter Return only usages specified in the filter. Filter is specified by using OData syntax. Example: $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq '2014-01-01T00:00:00Z' and endTime eq '2014-12-31T23:59:59Z' and timeGrain eq duration'[Hour|Minute|Day]'.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSinglePageAsync(final String resourceGroupName, final String name, final String filter) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listUsages(resourceGroupName, name, this.client.subscriptionId(), filter, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the List&lt;VnetInfoInner&gt; object if successful.
     */
    public List<VnetInfoInner> listVnetConnections(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).toBlocking().single().getBody();
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name, final ServiceCallback<List<VnetInfoInner>> serviceCallback) {
        return ServiceCall.create(listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name), serviceCallback);
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<List<VnetInfoInner>> listVnetConnectionsAsync(String resourceGroupName, String name) {
        return listVnetConnectionsWithServiceResponseAsync(resourceGroupName, name).map(new Func1<ServiceResponse<List<VnetInfoInner>>, List<VnetInfoInner>>() {
            @Override
            public List<VnetInfoInner> call(ServiceResponse<List<VnetInfoInner>> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     * Retrieves a list of all Virtual Network Connections associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @return the observable to the List&lt;VnetInfoInner&gt; object
     */
    public Observable<ServiceResponse<List<VnetInfoInner>>> listVnetConnectionsWithServiceResponseAsync(String resourceGroupName, String name) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.listVnetConnections(resourceGroupName, name, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VnetInfoInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<VnetInfoInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VnetInfoInner>> clientResponse = listVnetConnectionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VnetInfoInner>> listVnetConnectionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<List<VnetInfoInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<VnetInfoInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner getVnetConnection(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> getVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return getVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a specific Virtual Network Connection associated with this web app.
     * Retrieves a specific Virtual Network Connection associated with this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> getVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = getVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> getVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner createOrUpdateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> createOrUpdateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return createOrUpdateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> createOrUpdateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = createOrUpdateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> createOrUpdateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the Object object if successful.
     */
    public Object deleteVnetConnection(String resourceGroupName, String name, String vnetName) {
        return deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).toBlocking().single().getBody();
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName), serviceCallback);
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the Object object
     */
    public Observable<Object> deleteVnetConnectionAsync(String resourceGroupName, String name, String vnetName) {
        return deleteVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Removes the specified Virtual Network Connection association from this web app.
     * Removes the specified Virtual Network Connection association from this web app.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> deleteVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.deleteVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = deleteVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> deleteVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the VnetInfoInner object if successful.
     */
    public VnetInfoInner updateVnetConnection(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope, final ServiceCallback<VnetInfoInner> serviceCallback) {
        return ServiceCall.create(updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope), serviceCallback);
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<VnetInfoInner> updateVnetConnectionAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        return updateVnetConnectionWithServiceResponseAsync(resourceGroupName, name, vnetName, connectionEnvelope).map(new Func1<ServiceResponse<VnetInfoInner>, VnetInfoInner>() {
            @Override
            public VnetInfoInner call(ServiceResponse<VnetInfoInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Adds a Virtual Network Connection or updates it's properties.
     * Adds a Virtual Network Connection or updates it's properties.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param connectionEnvelope The properties of this Virtual Network Connection
     * @return the observable to the VnetInfoInner object
     */
    public Observable<ServiceResponse<VnetInfoInner>> updateVnetConnectionWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, VnetInfoInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnection(resourceGroupName, name, vnetName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetInfoInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetInfoInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetInfoInner> clientResponse = updateVnetConnectionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetInfoInner> updateVnetConnectionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetInfoInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetInfoInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the Object object if successful.
     */
    public Object getVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).toBlocking().single().getBody();
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Object> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, final ServiceCallback<Object> serviceCallback) {
        return ServiceCall.create(getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName), serviceCallback);
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the observable to the Object object
     */
    public Observable<Object> getVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        return getVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     * Retrieves a Virtual Network connection gateway associated with this web app and virtual network.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        final String apiVersion = "2016-08-01";
        return service.getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<Object, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner createOrUpdateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> createOrUpdateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> createOrUpdateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = createOrUpdateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> createOrUpdateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the VnetGatewayInner object if successful.
     */
    public VnetGatewayInner updateVnetConnectionGateway(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).toBlocking().single().getBody();
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope, final ServiceCallback<VnetGatewayInner> serviceCallback) {
        return ServiceCall.create(updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope), serviceCallback);
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<VnetGatewayInner> updateVnetConnectionGatewayAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        return updateVnetConnectionGatewayWithServiceResponseAsync(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope).map(new Func1<ServiceResponse<VnetGatewayInner>, VnetGatewayInner>() {
            @Override
            public VnetGatewayInner call(ServiceResponse<VnetGatewayInner> response) {
                return response.getBody();
            }
        });
    }

    /**
     * Updates the Virtual Network Gateway.
     * Updates the Virtual Network Gateway.
     *
     * @param resourceGroupName The resource group name
     * @param name The name of the web app
     * @param vnetName The name of the Virtual Network
     * @param gatewayName The name of the gateway. The only gateway that exists presently is "primary"
     * @param connectionEnvelope The properties to update this gateway with.
     * @return the observable to the VnetGatewayInner object
     */
    public Observable<ServiceResponse<VnetGatewayInner>> updateVnetConnectionGatewayWithServiceResponseAsync(String resourceGroupName, String name, String vnetName, String gatewayName, VnetGatewayInner connectionEnvelope) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (vnetName == null) {
            throw new IllegalArgumentException("Parameter vnetName is required and cannot be null.");
        }
        if (gatewayName == null) {
            throw new IllegalArgumentException("Parameter gatewayName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (connectionEnvelope == null) {
            throw new IllegalArgumentException("Parameter connectionEnvelope is required and cannot be null.");
        }
        Validator.validate(connectionEnvelope);
        final String apiVersion = "2016-08-01";
        return service.updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, this.client.subscriptionId(), connectionEnvelope, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<VnetGatewayInner>>>() {
                @Override
                public Observable<ServiceResponse<VnetGatewayInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<VnetGatewayInner> clientResponse = updateVnetConnectionGatewayDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<VnetGatewayInner> updateVnetConnectionGatewayDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<VnetGatewayInner, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<VnetGatewayInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all Web Apps for a subscription.
     * Gets all Web Apps for a subscription.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeletedSiteInner&gt; object if successful.
     */
    public PagedList<DeletedSiteInner> listDeletedNext(final String nextPageLink) {
        ServiceResponse<Page<DeletedSiteInner>> response = listDeletedNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeletedSiteInner>(response.getBody()) {
            @Override
            public Page<DeletedSiteInner> nextPage(String nextPageLink) {
                return listDeletedNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeletedSiteInner>> listDeletedNextAsync(final String nextPageLink, final ServiceCall<List<DeletedSiteInner>> serviceCall, final ListOperationCallback<DeletedSiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeletedNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(String nextPageLink) {
                    return listDeletedNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<Page<DeletedSiteInner>> listDeletedNextAsync(final String nextPageLink) {
        return listDeletedNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Page<DeletedSiteInner>>() {
                @Override
                public Page<DeletedSiteInner> call(ServiceResponse<Page<DeletedSiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeletedSiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeletedNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeletedSiteInner>>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(ServiceResponse<Page<DeletedSiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeletedNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets deleted web apps in subscription.
     * Gets deleted web apps in subscription.
     *
    ServiceResponse<PageImpl<DeletedSiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeletedSiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeletedSiteInner>>> listDeletedNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listDeletedNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeletedSiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeletedSiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeletedSiteInner>> result = listDeletedNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeletedSiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeletedSiteInner>> listDeletedNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeletedSiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeletedSiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listByResourceGroupNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listByResourceGroupNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listByResourceGroupNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listByResourceGroupNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextWithServiceResponseAsync(final String nextPageLink) {
        return listByResourceGroupNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listByResourceGroupNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the web apps for a subscription in the specified resource group.
     * Gets the web apps for a subscription in the specified resource group.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listByResourceGroupNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listByResourceGroupNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listByResourceGroupNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listByResourceGroupNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listBackupsNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listBackupsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsNextAsync(final String nextPageLink) {
        return listBackupsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listBackupsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsNextAsync(final String nextPageLink) {
        return listDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            listHostNameBindingsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsNextAsync(final String nextPageLink) {
        return listHostNameBindingsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listHostNameBindingsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceIdentifiersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listInstanceIdentifiersNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listInstanceDeploymentsNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceDeploymentsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsNextAsync(final String nextPageLink) {
        return listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceDeploymentsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listInstanceDeploymentsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefinitionsNext(final String nextPageLink) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefinitionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefinitionsNextAsync(final String nextPageLink) {
        return listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricDefinitionsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefinitionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefinitionsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsNextAsync(final String nextPageLink) {
        return listMetricsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink, final ServiceCall<List<PerfMonResponseInner>> serviceCall, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersNextAsync(final String nextPageLink) {
        return listPerfMonCountersNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listPerfMonCountersNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<PerfMonResponseInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object if successful.
     */
    public PagedList<SiteInner> listSlotsNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInner>> response = listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInner>(response.getBody()) {
            @Override
            public Page<SiteInner> nextPage(String nextPageLink) {
                return listSlotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInner>> listSlotsNextAsync(final String nextPageLink, final ServiceCall<List<SiteInner>> serviceCall, final ListOperationCallback<SiteInner> serviceCallback) {
        return AzureServiceCall.create(
            listSlotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(String nextPageLink) {
                    return listSlotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<Page<SiteInner>> listSlotsNextAsync(final String nextPageLink) {
        return listSlotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInner>>, Page<SiteInner>>() {
                @Override
                public Page<SiteInner> call(ServiceResponse<Page<SiteInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSlotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInner>>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(ServiceResponse<Page<SiteInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSlotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all the slots for a web apps.
     * Gets all the slots for a web apps.
     *
    ServiceResponse<PageImpl<SiteInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInner>>> listSlotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSlotsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInner>> result = listSlotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInner>> listSlotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object if successful.
     */
    public PagedList<BackupItemInner> listBackupsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<BackupItemInner>> response = listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<BackupItemInner>(response.getBody()) {
            @Override
            public Page<BackupItemInner> nextPage(String nextPageLink) {
                return listBackupsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink, final ServiceCall<List<BackupItemInner>> serviceCall, final ListOperationCallback<BackupItemInner> serviceCallback) {
        return AzureServiceCall.create(
            listBackupsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(String nextPageLink) {
                    return listBackupsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<Page<BackupItemInner>> listBackupsSlotNextAsync(final String nextPageLink) {
        return listBackupsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<BackupItemInner>>, Page<BackupItemInner>>() {
                @Override
                public Page<BackupItemInner> call(ServiceResponse<Page<BackupItemInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;BackupItemInner&gt; object
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listBackupsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<BackupItemInner>>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(ServiceResponse<Page<BackupItemInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listBackupsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Lists all available backups for web app.
     * Lists all available backups for web app.
     *
    ServiceResponse<PageImpl<BackupItemInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;BackupItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<BackupItemInner>>> listBackupsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listBackupsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<BackupItemInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<BackupItemInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<BackupItemInner>> result = listBackupsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<BackupItemInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<BackupItemInner>> listBackupsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<BackupItemInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<BackupItemInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listDeploymentsSlotNextAsync(final String nextPageLink) {
        return listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object if successful.
     */
    public PagedList<HostNameBindingInner> listHostNameBindingsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<HostNameBindingInner>> response = listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HostNameBindingInner>(response.getBody()) {
            @Override
            public Page<HostNameBindingInner> nextPage(String nextPageLink) {
                return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink, final ServiceCall<List<HostNameBindingInner>> serviceCall, final ListOperationCallback<HostNameBindingInner> serviceCallback) {
        return AzureServiceCall.create(
            listHostNameBindingsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(String nextPageLink) {
                    return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<Page<HostNameBindingInner>> listHostNameBindingsSlotNextAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Page<HostNameBindingInner>>() {
                @Override
                public Page<HostNameBindingInner> call(ServiceResponse<Page<HostNameBindingInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;HostNameBindingInner&gt; object
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listHostNameBindingsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<HostNameBindingInner>>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(ServiceResponse<Page<HostNameBindingInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listHostNameBindingsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get web app hostname bindings.
     * Get web app hostname bindings.
     *
    ServiceResponse<PageImpl<HostNameBindingInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;HostNameBindingInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<HostNameBindingInner>>> listHostNameBindingsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listHostNameBindingsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<HostNameBindingInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<HostNameBindingInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<HostNameBindingInner>> result = listHostNameBindingsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<HostNameBindingInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<HostNameBindingInner>> listHostNameBindingsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<HostNameBindingInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<HostNameBindingInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object if successful.
     */
    public PagedList<SiteInstanceInner> listInstanceIdentifiersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SiteInstanceInner>> response = listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SiteInstanceInner>(response.getBody()) {
            @Override
            public Page<SiteInstanceInner> nextPage(String nextPageLink) {
                return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink, final ServiceCall<List<SiteInstanceInner>> serviceCall, final ListOperationCallback<SiteInstanceInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(String nextPageLink) {
                    return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<Page<SiteInstanceInner>> listInstanceIdentifiersSlotNextAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Page<SiteInstanceInner>>() {
                @Override
                public Page<SiteInstanceInner> call(ServiceResponse<Page<SiteInstanceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SiteInstanceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceIdentifiersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SiteInstanceInner>>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(ServiceResponse<Page<SiteInstanceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceIdentifiersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets all instance of a web app.
     * Gets all instance of a web app.
     *
    ServiceResponse<PageImpl<SiteInstanceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SiteInstanceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SiteInstanceInner>>> listInstanceIdentifiersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listInstanceIdentifiersSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SiteInstanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SiteInstanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SiteInstanceInner>> result = listInstanceIdentifiersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SiteInstanceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SiteInstanceInner>> listInstanceIdentifiersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SiteInstanceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SiteInstanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object if successful.
     */
    public PagedList<DeploymentInner> listInstanceDeploymentsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<DeploymentInner>> response = listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<DeploymentInner>(response.getBody()) {
            @Override
            public Page<DeploymentInner> nextPage(String nextPageLink) {
                return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<DeploymentInner>> listInstanceDeploymentsSlotNextAsync(final String nextPageLink, final ServiceCall<List<DeploymentInner>> serviceCall, final ListOperationCallback<DeploymentInner> serviceCallback) {
        return AzureServiceCall.create(
            listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(String nextPageLink) {
                    return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<Page<DeploymentInner>> listInstanceDeploymentsSlotNextAsync(final String nextPageLink) {
        return listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<DeploymentInner>>, Page<DeploymentInner>>() {
                @Override
                public Page<DeploymentInner> call(ServiceResponse<Page<DeploymentInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;DeploymentInner&gt; object
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listInstanceDeploymentsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<DeploymentInner>>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(ServiceResponse<Page<DeploymentInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listInstanceDeploymentsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * List deployments.
     * List deployments.
     *
    ServiceResponse<PageImpl<DeploymentInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;DeploymentInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<DeploymentInner>>> listInstanceDeploymentsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listInstanceDeploymentsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<DeploymentInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DeploymentInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<DeploymentInner>> result = listInstanceDeploymentsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<DeploymentInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<DeploymentInner>> listInstanceDeploymentsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<DeploymentInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<DeploymentInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object if successful.
     */
    public PagedList<MetricDefinitionInner> listMetricDefinitionsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<MetricDefinitionInner>> response = listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<MetricDefinitionInner>(response.getBody()) {
            @Override
            public Page<MetricDefinitionInner> nextPage(String nextPageLink) {
                return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<MetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink, final ServiceCall<List<MetricDefinitionInner>> serviceCall, final ListOperationCallback<MetricDefinitionInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(String nextPageLink) {
                    return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<Page<MetricDefinitionInner>> listMetricDefinitionsSlotNextAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Page<MetricDefinitionInner>>() {
                @Override
                public Page<MetricDefinitionInner> call(ServiceResponse<Page<MetricDefinitionInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;MetricDefinitionInner&gt; object
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricDefinitionsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<MetricDefinitionInner>>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(ServiceResponse<Page<MetricDefinitionInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricDefinitionsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metric definitions for web app.
     * Gets metric definitions for web app.
     *
    ServiceResponse<PageImpl<MetricDefinitionInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;MetricDefinitionInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<MetricDefinitionInner>>> listMetricDefinitionsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricDefinitionsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<MetricDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<MetricDefinitionInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<MetricDefinitionInner>> result = listMetricDefinitionsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<MetricDefinitionInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<MetricDefinitionInner>> listMetricDefinitionsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<MetricDefinitionInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<MetricDefinitionInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object if successful.
     */
    public PagedList<ResourceMetricInner> listMetricsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<ResourceMetricInner>> response = listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ResourceMetricInner>(response.getBody()) {
            @Override
            public Page<ResourceMetricInner> nextPage(String nextPageLink) {
                return listMetricsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink, final ServiceCall<List<ResourceMetricInner>> serviceCall, final ListOperationCallback<ResourceMetricInner> serviceCallback) {
        return AzureServiceCall.create(
            listMetricsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(String nextPageLink) {
                    return listMetricsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<Page<ResourceMetricInner>> listMetricsSlotNextAsync(final String nextPageLink) {
        return listMetricsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Page<ResourceMetricInner>>() {
                @Override
                public Page<ResourceMetricInner> call(ServiceResponse<Page<ResourceMetricInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;ResourceMetricInner&gt; object
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listMetricsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMetricsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets metrics for web app.
     * Gets metrics for web app.
     *
    ServiceResponse<PageImpl<ResourceMetricInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;ResourceMetricInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMetricsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listMetricsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ResourceMetricInner>> result = listMetricsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ResourceMetricInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ResourceMetricInner>> listMetricsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<ResourceMetricInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<ResourceMetricInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object if successful.
     */
    public PagedList<PerfMonResponseInner> listPerfMonCountersSlotNext(final String nextPageLink) {
        ServiceResponse<Page<PerfMonResponseInner>> response = listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<PerfMonResponseInner>(response.getBody()) {
            @Override
            public Page<PerfMonResponseInner> nextPage(String nextPageLink) {
                return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink, final ServiceCall<List<PerfMonResponseInner>> serviceCall, final ListOperationCallback<PerfMonResponseInner> serviceCallback) {
        return AzureServiceCall.create(
            listPerfMonCountersSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(String nextPageLink) {
                    return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<Page<PerfMonResponseInner>> listPerfMonCountersSlotNextAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Page<PerfMonResponseInner>>() {
                @Override
                public Page<PerfMonResponseInner> call(ServiceResponse<Page<PerfMonResponseInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;PerfMonResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listPerfMonCountersSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<PerfMonResponseInner>>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(ServiceResponse<Page<PerfMonResponseInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listPerfMonCountersSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets perfmon counters for web app.
     * Gets perfmon counters for web app.
     *
    ServiceResponse<PageImpl<PerfMonResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;PerfMonResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<PerfMonResponseInner>>> listPerfMonCountersSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listPerfMonCountersSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<PerfMonResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<PerfMonResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<PerfMonResponseInner>> result = listPerfMonCountersSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<PerfMonResponseInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<PerfMonResponseInner>> listPerfMonCountersSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<PerfMonResponseInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<PerfMonResponseInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesSlotNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesSlotNextAsync(final String nextPageLink) {
        return getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return getSlotsDifferencesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsSlotNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.getBody()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink, final ServiceCall<List<SnapshotInner>> serviceCall, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceCall.create(
            listSnapshotsSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsSlotNextAsync(final String nextPageLink) {
        return listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSnapshotsSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SnapshotInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesSlotNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesSlotNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesSlotNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesSlotNextAsync(final String nextPageLink) {
        return listUsagesSlotNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesSlotNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesSlotNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesSlotNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listUsagesSlotNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesSlotNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesSlotNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object if successful.
     */
    public PagedList<SlotDifferenceInner> getSlotsDifferencesFromProductionNext(final String nextPageLink) {
        ServiceResponse<Page<SlotDifferenceInner>> response = getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SlotDifferenceInner>(response.getBody()) {
            @Override
            public Page<SlotDifferenceInner> nextPage(String nextPageLink) {
                return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink, final ServiceCall<List<SlotDifferenceInner>> serviceCall, final ListOperationCallback<SlotDifferenceInner> serviceCallback) {
        return AzureServiceCall.create(
            getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(String nextPageLink) {
                    return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<Page<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextAsync(final String nextPageLink) {
        return getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Page<SlotDifferenceInner>>() {
                @Override
                public Page<SlotDifferenceInner> call(ServiceResponse<Page<SlotDifferenceInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SlotDifferenceInner&gt; object
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextWithServiceResponseAsync(final String nextPageLink) {
        return getSlotsDifferencesFromProductionNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SlotDifferenceInner>>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(ServiceResponse<Page<SlotDifferenceInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(getSlotsDifferencesFromProductionNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get the difference in configuration settings between two web app slots.
     * Get the difference in configuration settings between two web app slots.
     *
    ServiceResponse<PageImpl<SlotDifferenceInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SlotDifferenceInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SlotDifferenceInner>>> getSlotsDifferencesFromProductionNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.getSlotsDifferencesFromProductionNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SlotDifferenceInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SlotDifferenceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SlotDifferenceInner>> result = getSlotsDifferencesFromProductionNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SlotDifferenceInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SlotDifferenceInner>> getSlotsDifferencesFromProductionNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SlotDifferenceInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SlotDifferenceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SnapshotInner&gt; object if successful.
     */
    public PagedList<SnapshotInner> listSnapshotsNext(final String nextPageLink) {
        ServiceResponse<Page<SnapshotInner>> response = listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<SnapshotInner>(response.getBody()) {
            @Override
            public Page<SnapshotInner> nextPage(String nextPageLink) {
                return listSnapshotsNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink, final ServiceCall<List<SnapshotInner>> serviceCall, final ListOperationCallback<SnapshotInner> serviceCallback) {
        return AzureServiceCall.create(
            listSnapshotsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(String nextPageLink) {
                    return listSnapshotsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<Page<SnapshotInner>> listSnapshotsNextAsync(final String nextPageLink) {
        return listSnapshotsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<SnapshotInner>>, Page<SnapshotInner>>() {
                @Override
                public Page<SnapshotInner> call(ServiceResponse<Page<SnapshotInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;SnapshotInner&gt; object
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextWithServiceResponseAsync(final String nextPageLink) {
        return listSnapshotsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<SnapshotInner>>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(ServiceResponse<Page<SnapshotInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listSnapshotsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Returns all Snapshots to the user.
     * Returns all Snapshots to the user.
     *
    ServiceResponse<PageImpl<SnapshotInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;SnapshotInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<SnapshotInner>>> listSnapshotsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listSnapshotsNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<SnapshotInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<SnapshotInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<SnapshotInner>> result = listSnapshotsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<SnapshotInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<SnapshotInner>> listSnapshotsNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SnapshotInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<SnapshotInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object if successful.
     */
    public PagedList<CsmUsageQuotaInner> listUsagesNext(final String nextPageLink) {
        ServiceResponse<Page<CsmUsageQuotaInner>> response = listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<CsmUsageQuotaInner>(response.getBody()) {
            @Override
            public Page<CsmUsageQuotaInner> nextPage(String nextPageLink) {
                return listUsagesNextSinglePageAsync(nextPageLink).toBlocking().single().getBody();
            }
        };
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<List<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink, final ServiceCall<List<CsmUsageQuotaInner>> serviceCall, final ListOperationCallback<CsmUsageQuotaInner> serviceCallback) {
        return AzureServiceCall.create(
            listUsagesNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(String nextPageLink) {
                    return listUsagesNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<Page<CsmUsageQuotaInner>> listUsagesNextAsync(final String nextPageLink) {
        return listUsagesNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Page<CsmUsageQuotaInner>>() {
                @Override
                public Page<CsmUsageQuotaInner> call(ServiceResponse<Page<CsmUsageQuotaInner>> response) {
                    return response.getBody();
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the observable to the PagedList&lt;CsmUsageQuotaInner&gt; object
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextWithServiceResponseAsync(final String nextPageLink) {
        return listUsagesNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<CsmUsageQuotaInner>>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(ServiceResponse<Page<CsmUsageQuotaInner>> page) {
                    String nextPageLink = page.getBody().getNextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listUsagesNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Gets the quota usage numbers for web app.
     * Gets the quota usage numbers for web app.
     *
    ServiceResponse<PageImpl<CsmUsageQuotaInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @return the PagedList&lt;CsmUsageQuotaInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> listUsagesNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        return service.listUsagesNext(nextPageLink, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<CsmUsageQuotaInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<CsmUsageQuotaInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<CsmUsageQuotaInner>> result = listUsagesNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<CsmUsageQuotaInner>>(result.getBody(), result.getResponse()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<CsmUsageQuotaInner>> listUsagesNextDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CsmUsageQuotaInner>, CloudException>(this.client.mapperAdapter())
                .register(200, new TypeToken<PageImpl<CsmUsageQuotaInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
